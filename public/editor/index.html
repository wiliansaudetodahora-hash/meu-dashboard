<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creative Pro - Editor de Criativos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #111015;
            --bg-panel: #1F1D24;
            --bg-controls: #27252C;
            --text-primary: #f0f0f5;
            --text-secondary: #a0a0b0;
            --accent: #8A63D2;
            --success: #28a745;
            --error: #dc3545;
            --border-color: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .editor-container {
            display: flex;
            height: 100vh;
        }

        /* --- Barra de √çcones Lateral --- */
        .icon-bar {
            width: 80px;
            background-color: var(--bg-panel);
            padding: 1rem 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            border-right: 1px solid var(--border-color);
        }
        .nav-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
            transition: color 0.2s ease;
            width: 100%;
            padding: 0.5rem 0;
        }
        .nav-btn svg {
            width: 28px;
            height: 28px;
        }
        .nav-btn:hover, .nav-btn.active {
            color: var(--text-primary);
            background-color: rgba(255,255,255,0.05);
        }

        /* --- Painel de Controles --- */
        .controls-panel {
            width: 380px;
            background-color: var(--bg-controls);
            padding: 1.5rem;
            overflow-y: auto;
            height: 100%;
        }
        .control-section {
            display: none;
        }
        .control-section.active {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        /* --- √Årea de Pr√©-visualiza√ß√£o --- */
        .preview-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .top-header {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 1rem 2rem;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            gap: 1rem;
        }
        .preview-panel {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }
        .canvas-wrapper {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease-in-out;
        }
        #outputCanvas {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background-color: var(--bg-dark);
            cursor: default;
        }
        #outputCanvas.grabbing {
            cursor: grabbing;
        }
        #outputCanvas.grab {
            cursor: grab;
        }

        /* --- Componentes de UI --- */
        .card {
            background-color: var(--bg-panel);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }
        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .reset-btn {
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-secondary);
            background: none;
            border: none;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .reset-btn:hover {
            color: var(--accent);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.9rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: white;
        }
        .btn-primary {
            background-image: linear-gradient(to right, #8A63D2, #667eea);
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(138, 99, 210, 0.3);
        }
        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* --- Inputs e Controles --- */
        .form-input, textarea {
            width: 100%;
            padding: 0.75rem;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: inherit;
        }
        #upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        #upload-area.dragging {
            border-color: var(--accent);
            background-color: rgba(138, 99, 210, 0.1);
        }
        #upload-area p {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        #upload-area span {
            color: var(--accent);
            font-weight: 600;
        }
        
        #gallery-container, #logo-gallery-container, #filters-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
            max-height: 40vh;
            overflow-y: auto;
            padding: 0.5rem;
        }
        .gallery-item, .filter-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        .gallery-thumbnail, .filter-thumbnail {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            border: 3px solid transparent;
            background-size: cover;
            background-position: center;
            transition: all 0.2s ease;
        }
        #logo-gallery-container .gallery-thumbnail {
            background-size: contain;
            background-repeat: no-repeat;
        }
        .gallery-item:hover .gallery-thumbnail,
        .filter-item:hover .filter-thumbnail {
            transform: scale(1.05);
            border-color: var(--text-secondary);
        }
        .gallery-thumbnail.active,
        .filter-thumbnail.active {
            border-color: var(--accent);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(138, 99, 210, 0.4);
        }
        .gallery-name, .filter-name {
            font-size: 0.7rem;
            color: var(--text-secondary);
            width: 100%;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .delete-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: var(--error);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: scale(0.8);
            z-index: 10;
        }
        .gallery-item:hover .delete-btn {
            opacity: 1;
            transform: scale(1);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 0.75rem;
        }
        .control-btn {
            padding: 0.6rem;
            font-size: 0.85rem;
            font-weight: 500;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
            position: relative;
        }
        .control-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }
        .control-btn.active {
            border-color: var(--accent);
            background-color: rgba(138, 99, 210, 0.2);
            color: white;
            font-weight: 600;
        }
        .delete-template-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background-color: var(--error);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: scale(0.8);
        }
        .control-btn:hover .delete-template-btn {
            opacity: 1;
            transform: scale(1);
        }

        #headline-buttons-container {
            max-height: 150px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding-right: 0.5rem;
            margin-top: 1rem;
        }
        .headline-btn {
            width: 100%;
            text-align: left;
            padding: 0.6rem 0.8rem;
            font-size: 0.85rem;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .headline-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }
        .headline-btn.active {
            border-color: var(--accent);
            background-color: rgba(138, 99, 210, 0.2);
            color: white;
            font-weight: 600;
        }

        .visual-btn {
            background-color: transparent;
            border: 2px solid var(--border-color);
            padding: 0.5rem;
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        .visual-btn:hover {
            border-color: var(--text-primary);
        }
        .visual-btn.active {
            border-color: var(--accent);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(138, 99, 210, 0.4);
        }
        .visual-btn svg {
            width: 100%;
            height: 100%;
        }

        .slider-container {
            margin-top: 1rem;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        input[type="range"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            background-color: transparent;
            border: none;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch {
            border-radius: 50%;
            border: 2px solid var(--border-color);
        }
        input[type="color"]::-moz-color-swatch {
            border-radius: 50%;
            border: 2px solid var(--border-color);
        }

        #notification {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translate(-50%, 200%);
            padding: 1rem 2rem;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.4s ease-in-out;
            z-index: 1000;
        }
        #notification.show {
            transform: translate(-50%, 0);
        }
        #notification.success {
            background-color: var(--success);
        }
        #notification.error {
            background-color: var(--error);
        }
        
        .hidden {
            display: none !important;
        }
        #logo-controls {
            border-top: 1px solid var(--border-color);
            margin-top: 1.5rem;
            padding-top: 1.5rem;
        }

        .export-settings {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
        }

        /* Estilos adicionais para o painel de IA */
        .ai-section {
            margin-bottom: 1.5rem;
        }
        .ai-section h3 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }
        .ai-status {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }
        .ai-results {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        .ai-suggestions {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        .ai-options {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .api-config {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .api-hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }
        .api-hint a {
            color: var(--accent);
        }
        .btn-ai {
            background-color: var(--accent);
            color: white;
            padding: 0.6rem 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }
        .btn-ai:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(138, 99, 210, 0.3);
        }
        .btn-ai:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <!-- BARRA DE √çCONES LATERAL -->
        <nav class="icon-bar">
            <!-- LOGO DA EMPRESA -->
            <div style="padding-bottom: 1rem; border-bottom: 1px solid var(--border-color); margin-bottom: -0.5rem;">
                <svg width="60" height="60" viewBox="0 0 60 60" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="up-logo-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#2563EB;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#06B6D4;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <g transform="translate(5, 10)">
                        <path d="M 5 5 L 5 25 C 5 30 8 33 13 33 C 18 33 21 30 21 25 L 21 5 L 17 5 L 17 25 C 17 27.5 15.5 29 13 29 C 10.5 29 9 27.5 9 25 L 9 5 Z" fill="url(#up-logo-gradient)"/>
                        <path d="M 25 5 L 25 33 L 29 33 L 29 20 L 35 20 C 39.5 20 43 16.5 43 12 C 43 7.5 39.5 5 35 5 Z M 29 9 L 35 9 C 37.2 9 39 10.3 39 12 C 39 13.7 37.2 16 35 16 L 29 16 Z" fill="url(#up-logo-gradient)"/>
                        <path d="M 35 11 L 40 16 L 35 21" fill="none" stroke="#1EE3A6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" transform="translate(-5, -4.5) scale(0.8)"/>
                    </g>
                </svg>
            </div>
            <button class="nav-btn active" data-panel="multimedia-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                <span>Multim√≠dia</span>
            </button>
            <button class="nav-btn" data-panel="filters-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 2a7 7 0 1 0 10 10"></path></svg>
                <span>Filtros</span>
            </button>
            <button class="nav-btn" data-panel="templates-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
                <span>Templates</span>
            </button>
            <button class="nav-btn" data-panel="text-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>
                <span>Texto</span>
            </button>
            <button class="nav-btn" data-panel="elements-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path></svg>
                <span>Elementos</span>
            </button>
            <button class="nav-btn" data-panel="ai-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6m11-11h-6m-6 0H1"></path><circle cx="12" cy="12" r="10"></circle></svg>
                <span>IA</span>
            </button>
        </nav>

        <!-- PAINEL DE CONTROLES -->
        <aside class="controls-panel">
            <!-- Se√ß√£o Multim√≠dia -->
            <div id="multimedia-panel" class="control-section active">
                <div class="card">
                    <h2 class="card-title">
                        Galeria de Imagens
                        <button class="reset-btn" id="clear-gallery-btn">Limpar Tudo</button>
                    </h2>
                    <div id="upload-area">
                        <p>Arraste e solte ou <span>clique para importar fotos</span>.</p>
                    </div>
                    <div id="gallery-container"></div>
                    <input type="file" id="file-input" accept="image/*" hidden multiple>
                </div>
            </div>

            <!-- Se√ß√£o Filtros -->
            <div id="filters-panel" class="control-section">
                <div class="card">
                    <h2 class="card-title">
                        Filtros de Efeito
                        <button class="reset-btn" id="reset-filters-btn">Resetar</button>
                    </h2>
                    <div id="filters-container"></div>
                </div>
            </div>

            <!-- Se√ß√£o Templates -->
            <div id="templates-panel" class="control-section">
                <div class="card">
                    <h2 class="card-title">
                        Templates de Estilo
                        <button class="reset-btn" id="reset-templates-btn">Resetar</button>
                    </h2>
                    <div class="controls-grid" id="template-controls"></div>
                    <div id="custom-templates-container" class="controls-grid" style="margin-top: 0.75rem;"></div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                        <input type="text" id="new-template-name" class="form-input" placeholder="Nome do novo template...">
                        <button id="save-template-btn" class="btn btn-secondary" style="width: auto; padding: 0 1rem;">Salvar</button>
                    </div>
                </div>
            </div>

            <!-- Se√ß√£o Texto -->
            <div id="text-panel" class="control-section">
                <div class="card">
                    <h2 class="card-title">Adicionar Texto</h2>
                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: -0.8rem; margin-bottom: 1rem;">Arraste o texto na imagem para posicionar.</p>
                    <input type="text" id="custom-headline-input" class="form-input" placeholder="Ou digite seu texto aqui...">
                    <div id="headline-buttons-container"></div>
                    <h3 class="card-title" style="font-size: 0.9rem; margin-top: 1.5rem; margin-bottom: 0.75rem; border: none; padding-bottom: 0;">Fonte</h3>
                    <div class="controls-grid" id="font-family-controls">
                        <button class="control-btn" data-font="Default" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;">Padr√£o</button>
                        <button class="control-btn" data-font="Impact" style="font-family: Impact, sans-serif;">Impacto</button>
                        <button class="control-btn" data-font="Anton" style="font-family: 'Anton', sans-serif;">Anton</button>
                    </div>
                    <h3 class="card-title" style="font-size: 0.9rem; margin-top: 1.5rem; margin-bottom: 0.75rem; border: none; padding-bottom: 0;">Estilo do Fundo</h3>
                    <div class="controls-grid" id="text-background-controls">
                        <button class="control-btn" data-style="none">Nenhum</button>
                        <button class="control-btn" data-style="faixa">Faixa</button>
                        <button class="control-btn" data-style="capsule">C√°psula</button>
                        <button class="control-btn" data-style="vazado">Vazado</button>
                    </div>
                    <div style="display: flex; gap: 1rem; margin-top: 1.5rem; align-items: center; justify-content: space-around;">
                        <div style="text-align: center;">
                            <label style="font-size:0.8rem; color:var(--text-secondary); display: block; margin-bottom: 0.5rem;">Texto</label>
                            <input type="color" id="text-color-picker" title="Cor do Texto">
                        </div>
                        <div style="text-align: center;">
                            <label style="font-size:0.8rem; color:var(--text-secondary); display: block; margin-bottom: 0.5rem;">Fundo</label>
                            <input type="color" id="text-bg-color-picker" title="Cor do Fundo do Texto">
                        </div>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="text-bg-opacity-slider">Opacidade do Fundo</label>
                            <span id="text-bg-opacity-value">60%</span>
                        </div>
                        <input type="range" id="text-bg-opacity-slider" min="0" max="100">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="font-size-slider">Tamanho da Fonte</label>
                            <span id="font-size-value">80px</span>
                        </div>
                        <input type="range" id="font-size-slider" min="40" max="150">
                    </div>
                    <button id="remove-text-btn" class="btn btn-secondary" style="margin-top: 1.5rem;">Remover Texto</button>
                </div>
            </div>

            <!-- Se√ß√£o Elementos -->
            <div id="elements-panel" class="control-section">
                <div class="card">
                    <h2 class="card-title">Preenchimento de Bordas</h2>
                    <div class="controls-grid" id="fill-mode-controls">
                        <button class="control-btn" data-mode="blur-pro">Desfoque Pro</button>
                        <button class="control-btn" data-mode="edge-extend" title="Estende as bordas da imagem de forma impercept√≠vel">Edge Extend</button>
                        <button class="control-btn" data-mode="stretch">Esticado</button>
                        <button class="control-btn" data-mode="duotone">Duotone</button>
                        <button class="control-btn" data-mode="mosaic">Mosaico</button>
                        <button class="control-btn" data-mode="gradient">Gradiente</button>
                        <button class="control-btn" data-mode="solid">Cor S√≥lida</button>
                        <button class="control-btn" data-mode="smart" title="Escolhe automaticamente o melhor preenchimento">Inteligente</button>
                    </div>
                    <div id="fill-mode-options" style="margin-top: 1rem;"></div>
                </div>
                <div class="card">
                    <h2 class="card-title">Overlays de Doramas</h2>
                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: -0.8rem; margin-bottom: 1rem;">Adicione elementos t√≠picos de streaming de doramas.</p>
                    <button id="upload-logo-btn" class="btn btn-secondary">Importar Logo/Overlay</button>
                    <input type="file" id="logo-file-input" accept="image/png, image/webp" hidden>
                    <div id="logo-gallery-container"></div>
                    <div id="logo-controls" class="hidden">
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="logo-scale-slider">Tamanho</label>
                                <span id="logo-scale-value">50%</span>
                            </div>
                            <input type="range" id="logo-scale-slider" min="10" max="150" value="50">
                        </div>
                        <button id="remove-logo-btn" class="btn btn-secondary" style="margin-top: 1.5rem;">Remover Overlay</button>
                    </div>
                    <!-- Elementos pr√©-definidos de doramas -->
                    <div style="margin-top: 1rem;">
                        <h4 style="font-size: 0.9rem; margin-bottom: 0.75rem;">Elementos R√°pidos</h4>
                        <div class="controls-grid">
                            <button class="control-btn" data-dorama="episode">EP Badge</button>
                            <button class="control-btn" data-dorama="subtitle">SUB Badge</button>
                            <button class="control-btn" data-dorama="hd">HD Badge</button>
                            <button class="control-btn" data-dorama="fullhd">FULL HD</button>
                            <button class="control-btn" data-dorama="new">NEW Badge</button>
                        </div>
                        <div id="dorama-elements-controls" style="display: none;">
                            <div class="slider-container" style="margin-top: 1rem;">
                                <div class="slider-label">
                                    <label for="dorama-elements-size-slider">Tamanho dos Badges</label>
                                    <span id="dorama-elements-size-value">100%</span>
                                </div>
                                <input type="range" id="dorama-elements-size-slider" min="30" max="300" value="100">
                            </div>
                            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 1rem;">
                                <label style="font-size: 0.9rem;">Cor do Badge:</label>
                                <input type="color" id="dorama-badge-color" value="#FF0000" title="Cor do Badge">
                                <button class="reset-btn" id="reset-badge-colors-btn">Cores Padr√£o</button>
                            </div>
                            <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem;">Arraste os badges na imagem para posicionar.</p>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h2 class="card-title">
                        Ajustes de Imagem
                        <button class="reset-btn" id="reset-image-adjustments-btn">Resetar</button>
                    </h2>
                    <div class="slider-container" style="margin-top: 0;">
                        <div class="slider-label">
                            <label for="brightness-slider">Brilho</label>
                            <span id="brightness-value">100%</span>
                        </div>
                        <input type="range" id="brightness-slider" min="0" max="200" value="100">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="contrast-slider">Contraste</label>
                            <span id="contrast-value">100%</span>
                        </div>
                        <input type="range" id="contrast-slider" min="0" max="200" value="100">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="saturate-slider">Satura√ß√£o</label>
                            <span id="saturate-value">100%</span>
                        </div>
                        <input type="range" id="saturate-slider" min="0" max="200" value="100">
                    </div>
                </div>
                <div class="card">
                    <h2 class="card-title">
                        Redimensionamento Manual
                        <button class="reset-btn" id="reset-transform-btn">Resetar</button>
                    </h2>
                    <div class="slider-container" style="margin-top: 0;">
                        <div class="slider-label">
                            <label for="image-scale-slider">Escala</label>
                            <span id="image-scale-value">100%</span>
                        </div>
                        <input type="range" id="image-scale-slider" min="10" max="200" value="100">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="image-x-slider">Posi√ß√£o X</label>
                            <span id="image-x-value">0px</span>
                        </div>
                        <input type="range" id="image-x-slider" min="-500" max="500" value="0">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="image-y-slider">Posi√ß√£o Y</label>
                            <span id="image-y-value">0px</span>
                        </div>
                        <input type="range" id="image-y-slider" min="-500" max="500" value="0">
                    </div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                        <button class="btn btn-secondary" id="center-image-btn" style="flex: 1;">Centralizar</button>
                        <button class="btn btn-secondary" id="fit-image-btn" style="flex: 1;">Ajustar</button>
                    </div>
                </div>
                <div class="card">
                    <h2 class="card-title">
                        Bot√£o de Play
                        <button class="reset-btn" id="reset-play-button-btn">Resetar</button>
                    </h2>
                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: -0.8rem; margin-bottom: 1rem;">Arraste o bot√£o na imagem para posicionar.</p>
                    <div class="controls-grid" id="play-button-controls">
                        <button class="visual-btn" data-type="none">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line><line x1="1" y1="1" x2="23" y2="23"></line></svg>
                        </button>
                        <button class="visual-btn" data-type="youtube">
                            <svg viewBox="0 0 48 48"><path fill="#FF0000" d="M42,16.4c-0.4-1.8-1.8-3.2-3.6-3.6C35.2,12,24,12,24,12s-11.2,0-14.4,0.8c-1.8,0.4-3.2,1.8-3.6,3.6C5.2,19.6,5.2,24,5.2,24s0,4.4,0.8,7.6c0.4,1.8,1.8,3.2,3.6,3.6C12.8,36,24,36,24,36s11.2,0,14.4-0.8c1.8-0.4,3.2-1.8,3.6-3.6C42.8,28.4,42.8,24,42.8,24S42.8,19.6,42,16.4z"></path><path fill="#FFFFFF" d="M20,29.5l10-5.5l-10-5.5V29.5z"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="new-tiktok">
                            <svg viewBox="0 0 48 48"><g><circle cx="27" cy="27" r="16" fill="#FF0050"></circle><circle cx="21" cy="21" r="16" fill="#00F2EA"></circle><circle cx="24" cy="24" r="14" fill="black"></circle><path fill="white" d="M21,18 l10,6 l-10,6 z"></path></g></svg>
                        </button>
                        <button class="visual-btn" data-type="gradient-circle">
                            <svg viewBox="0 0 48 48"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#8A2BE2" /><stop offset="100%" stop-color="#00BFFF" /></linearGradient></defs><circle cx="24" cy="24" r="18" stroke="url(#grad1)" stroke-width="4" fill="none"></circle><path d="M21 18 L31 24 L21 30 Z" fill="url(#grad1)"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="red-circle">
                            <svg viewBox="0 0 48 48"><circle cx="24" cy="24" r="20" fill="#FF0000"></circle><path d="M21 18 L31 24 L21 30 Z" fill="white"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="dashed-circle">
                            <svg viewBox="0 0 48 48"><circle cx="24" cy="24" r="18" stroke="#D32F2F" stroke-width="3" fill="none" stroke-dasharray="10 5" stroke-linecap="round"></circle><path d="M21 18 L31 24 L21 30 Z" fill="#D32F2F"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="simple-circle">
                            <svg viewBox="0 0 48 48"><circle cx="24" cy="24" r="22" fill="black"></circle><path d="M20 16 L32 24 L20 32 Z" fill="white"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="rounded-square">
                            <svg viewBox="0 0 48 48"><rect x="4" y="4" width="40" height="40" rx="8" fill="#212121"></rect><path d="M20 16 L32 24 L20 32 Z" fill="white"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="thick-border-circle">
                            <svg viewBox="0 0 48 48"><circle cx="24" cy="24" r="20" fill="white"></circle><circle cx="24" cy="24" r="16" fill="black"></circle><path d="M22 18 L30 24 L22 30 Z" fill="white"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="instagram">
                            <svg viewBox="0 0 48 48">
                                <circle cx="24" cy="24" r="22" fill="black"></circle>
                                <circle cx="24" cy="24" r="20" fill="white"></circle>
                                <path d="M21 18 L32 24 L21 30 Z" fill="black"></path>
                            </svg>
                        </button>
                        <button class="visual-btn" data-type="glossy-blue">
                            <svg viewBox="0 0 48 48">
                                <defs>
                                    <radialGradient id="glossyBlue" cx="50%" cy="80%" r="70%" fx="50%" fy="80%">
                                        <stop offset="0%" stop-color="#00BFFF" />
                                        <stop offset="100%" stop-color="#00529B" />
                                    </radialGradient>
                                    <linearGradient id="glossyShine" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" stop-color="white" stop-opacity="0.6" />
                                        <stop offset="50%" stop-color="white" stop-opacity="0.1" />
                                        <stop offset="100%" stop-color="white" stop-opacity="0.0" />
                                    </linearGradient>
                                </defs>
                                <circle cx="24" cy="24" r="22" fill="url(#glossyBlue)" />
                                <path d="M10,8 C10,0 38,0 38,8 A22 22 0 0 1 10 8" fill="url(#glossyShine)"/>
                                <path d="M20 16 L34 24 L20 32 Z" fill="white" stroke="rgba(0,0,0,0.2)" stroke-width="1"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="play-button-size-slider">Tamanho do Bot√£o</label>
                            <span id="play-button-size-value">120px</span>
                        </div>
                        <input type="range" id="play-button-size-slider" min="50" max="250" value="120">
                    </div>
                </div>
                <div class="card">
                    <h2 class="card-title">Exportar</h2>
                    <div class="controls-grid" id="format-controls">
                        <button class="control-btn active" data-format="jpeg">JPEG</button>
                        <button class="control-btn" data-format="png">PNG</button>
                        <button class="control-btn" data-format="webp">WebP</button>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="quality-slider">Qualidade</label>
                            <span id="quality-value">85%</span>
                        </div>
                        <input type="range" id="quality-slider" min="60" max="90" value="85">
                    </div>
                </div>
            </div>

            <!-- Se√ß√£o IA -->
            <div id="ai-panel" class="control-section">
                <div class="card">
                    <h2 class="card-title">ü§ñ Ferramentas de IA</h2>
                    
                    <!-- Remover Fundo -->
                    <div class="ai-section">
                        <h3 class="section-subtitle">Remover Fundo</h3>
                        <button id="remove-bg-btn" class="btn btn-ai">
                            <span>üéØ</span> Remover Fundo Automaticamente
                        </button>
                        <div id="remove-bg-status" class="ai-status"></div>
                    </div>

                    <!-- Upscale de Imagem -->
                    <div class="ai-section">
                        <h3 class="section-subtitle">Melhorar Qualidade</h3>
                        <div class="ai-options">
                            <select id="upscale-factor" class="form-select">
                                <option value="2">2x (Dobrar resolu√ß√£o)</option>
                                <option value="4">4x (Quadruplicar)</option>
                            </select>
                            <button id="upscale-btn" class="btn btn-ai">
                                <span>‚ú®</span> Aumentar Resolu√ß√£o
                            </button>
                        </div>
                        <div id="upscale-status" class="ai-status"></div>
                    </div>

                    <!-- Gera√ß√£o de Texto -->
                    <div class="ai-section">
                        <h3 class="section-subtitle">Gerar Texto Criativo</h3>
                        <input type="text" id="ai-text-prompt" class="form-input" 
                               placeholder="Ex: t√≠tulo rom√¢ntico para dorama coreano">
                        <div class="ai-options" style="display:flex; gap:0.5rem; align-items:center;">
                            <select id="text-style" class="form-select">
                                <option value="romantic">Rom√¢ntico</option>
                                <option value="dramatic">Dram√°tico</option>
                                <option value="comedy">Com√©dia</option>
                                <option value="thriller">Suspense</option>
                                <option value="viral">Viral/Clickbait</option>
                            </select>
                            <select id="text-language" class="form-select" title="Idioma do texto">
                                <option value="en">Ingl√™s</option>
                                <option value="es">Espanhol</option>
                            </select>
                            <button id="generate-text-btn" class="btn btn-ai">
                                <span>üí¨</span> Gerar Texto
                            </button>
                        </div>
                        <div id="ai-text-results" class="ai-results"></div>
                    </div>

                    <!-- Sugest√µes de Composi√ß√£o -->
                    <div class="ai-section">
                        <h3 class="section-subtitle">An√°lise Inteligente</h3>
                        <button id="analyze-composition-btn" class="btn btn-ai">
                            <span>üé®</span> Analisar Composi√ß√£o
                        </button>
                        <div id="composition-suggestions" class="ai-suggestions"></div>
                    </div>

                    <!-- Configura√ß√µes de API -->
                    <div class="ai-section" style="margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                        <h3 class="section-subtitle">‚öôÔ∏è Configura√ß√£o de APIs</h3>
                        <div class="api-config">
                            <input type="password" id="removebg-api-key" class="form-input" 
                                   placeholder="Remove.bg API Key">
                            <input type="password" id="openai-api-key" class="form-input" 
                                   placeholder="OpenAI API Key">
                            <button id="save-api-keys" class="btn btn-secondary">Salvar Chaves</button>
                        </div>
                        <p class="api-hint">
                            üîó <a href="https://remove.bg/users/sign_up" target="_blank">Obter Remove.bg Key</a> | 
                            <a href="https://platform.openai.com/api-keys" target="_blank">Obter OpenAI Key</a>
                        </p>
                    </div>
                </div>
            </div>

        </aside>

        <!-- √ÅREA DE PR√â-VISUALIZA√á√ÉO -->
        <main class="preview-area">
            <div class="top-header">
                <div style="margin-right: auto; display: flex; align-items: center; gap: 1.5rem;">
                    <div id="format-selector" style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-secondary" data-size="story" style="padding: 0.6rem 1rem; width: auto;">Story (9:16)</button>
                        <button class="btn btn-secondary" data-size="square" style="padding: 0.6rem 1rem; width: auto;">Quadrado (1:1)</button>
                        <button class="btn btn-secondary" data-size="feed" style="padding: 0.6rem 1rem; width: auto;">Feed (4:5)</button>
                        <button class="btn btn-secondary" data-size="vertical" style="padding: 0.6rem 1rem; width: auto;">Vertical (2:3)</button>
                    </div>
                </div>
                <button id="batch-process-btn" class="btn btn-secondary" style="margin-right: 0.5rem;">Processar Lote</button>
                <input type="text" id="export-filename-input" class="form-input" placeholder="Nome do arquivo..." style="width: 200px;">
                <button id="process-btn" class="btn btn-secondary">Exportar Imagem</button>
                <button id="generate-variations-btn" class="btn btn-primary">Gerar Varia√ß√µes</button>
                <input type="number" id="variations-count" class="form-input" value="10" min="1" max="50" style="width: 70px; text-align: center; padding: 0.6rem 0.5rem;">
            </div>
            <div class="preview-panel">
                <div class="canvas-wrapper">
                    <canvas id="outputCanvas"></canvas>
                </div>
            </div>
        </main>
    </div>

    <!-- Elemento de Notifica√ß√£o -->
    <div id="notification"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Polyfill para roundRect ---
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, radii) {
                // ...
                if (!Array.isArray(radii)) radii = [radii, radii, radii, radii];
                this.beginPath();
                this.moveTo(x + radii[0], y);
                this.lineTo(x + w - radii[1], y);
                this.quadraticCurveTo(x + w, y, x + w, y + radii[1]);
                this.lineTo(x + w, y + h - radii[2]);
                this.quadraticCurveTo(x + w, y + h, x + w - radii[2], y + h);
                this.lineTo(x + radii[3], y + h);
                this.quadraticCurveTo(x, y + h, x, y + h - radii[3]);
                this.lineTo(x, y + radii[0]);
                this.quadraticCurveTo(x, y, x + radii[0], y);
                this.closePath();
            };
        }

        // --- Vari√°veis Globais ---
        let processedBlob = null;
        let uploadedImages = [];
        let activeImageId = null;
        let isProcessing = false;
        let headlineSourceList = [];
        let customTemplates = [];
        let deletedDefaultTemplates = [];
        let imageIdCounter = 0;
        let savedLogos = [];
        let logoIdCounter = 0;
        let doramaElements = {
            episode: null,
            subtitle: null,
            hd: null,
            fullhd: null,
            new: null
        };
        let doramaElementsSize = 100; // Tamanho padr√£o em porcentagem
        let doramaBadgeColors = {
            episode: '#FF0000',
            subtitle: '#0099CC',
            hd: '#4CAF50',
            fullhd: '#9C27B0',
            new: '#FFA500'
        };
        const defaultBadgeColors = {
            episode: '#FF0000',
            subtitle: '#0099CC',
            hd: '#4CAF50',
            fullhd: '#9C27B0',
            new: '#FFA500'
        };

        // Vari√°veis de estado para arrastar elementos
        let isDragging = false;
        let draggingElement = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let snapStatus = { horizontal: false, vertical: false };

        let TARGET_WIDTH = 1080, TARGET_HEIGHT = 1920;
        // Debounce para redraw e opera√ß√µes pesadas
        let _redrawTimer = null;
        function requestRedraw() {
            if (_redrawTimer) cancelAnimationFrame(_redrawTimer);
            _redrawTimer = requestAnimationFrame(() => {
                redrawCanvas();
            });
        }
        const MAX_FILE_SIZE_KB = 500;

        // --- Seletores DOM ---
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = outputCanvas.getContext('2d');
        const qualitySlider = document.getElementById('quality-slider');
        const qualityValue = document.getElementById('quality-value');
        const processBtn = document.getElementById('process-btn');
        const notification = document.getElementById('notification');
        const headlineButtonsContainer = document.getElementById('headline-buttons-container');
        const generateVariationsBtn = document.getElementById('generate-variations-btn');
        const textColorPicker = document.getElementById('text-color-picker');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValue = document.getElementById('font-size-value');
        const removeTextBtn = document.getElementById('remove-text-btn');
        const textBgColorPicker = document.getElementById('text-bg-color-picker');
        const textBgOpacitySlider = document.getElementById('text-bg-opacity-slider');
        const textBgOpacityValue = document.getElementById('text-bg-opacity-value');
        const galleryContainer = document.getElementById('gallery-container');
        const playButtonSizeSlider = document.getElementById('play-button-size-slider');
        const playButtonSizeValue = document.getElementById('play-button-size-value');
        const brightnessSlider = document.getElementById('brightness-slider');
        const brightnessValue = document.getElementById('brightness-value');
        const contrastSlider = document.getElementById('contrast-slider');
        const contrastValue = document.getElementById('contrast-value');
        const saturateSlider = document.getElementById('saturate-slider');
        const saturateValue = document.getElementById('saturate-value');
        const resetImageAdjustmentsBtn = document.getElementById('reset-image-adjustments-btn');
        const resetPlayButtonBtn = document.getElementById('reset-play-button-btn');
        const customHeadlineInput = document.getElementById('custom-headline-input');
        const clearGalleryBtn = document.getElementById('clear-gallery-btn');
        const newTemplateNameInput = document.getElementById('new-template-name');
        const saveTemplateBtn = document.getElementById('save-template-btn');
        const customTemplatesContainer = document.getElementById('custom-templates-container');
        const templateControls = document.getElementById('template-controls');
        const resetTemplatesBtn = document.getElementById('reset-templates-btn');
        const variationsCountInput = document.getElementById('variations-count');
        const fillModeOptionsContainer = document.getElementById('fill-mode-options');
        const exportFilenameInput = document.getElementById('export-filename-input');
        const batchProcessBtn = document.getElementById('batch-process-btn');
        const uploadLogoBtn = document.getElementById('upload-logo-btn');
        const logoFileInput = document.getElementById('logo-file-input');
        const logoGalleryContainer = document.getElementById('logo-gallery-container');
        const logoControls = document.getElementById('logo-controls');
        const logoScaleSlider = document.getElementById('logo-scale-slider');
        const logoScaleValue = document.getElementById('logo-scale-value');
        const removeLogoBtn = document.getElementById('remove-logo-btn');
        const formatSelector = document.getElementById('format-selector');
        const canvasWrapper = document.querySelector('.canvas-wrapper');
        const filtersContainer = document.getElementById('filters-container');
        const resetFiltersBtn = document.getElementById('reset-filters-btn');
        const doramaElementsSizeSlider = document.getElementById('dorama-elements-size-slider');
        const doramaElementsSizeValue = document.getElementById('dorama-elements-size-value');
        const doramaElementsControls = document.getElementById('dorama-elements-controls');
        const doramaBadgeColorPicker = document.getElementById('dorama-badge-color');

        // --- Constantes ---
        const defaultHeadlines = [
            "WATCH FREE NOW", "STREAM NOW FREE", "FREE EPISODES HERE", "FINAL EPISODE FREE",
            "WATCH FULL DRAMA", "ALL EPISODES FREE", "TAP TO WATCH", "NEW KOREAN DRAMA",
            "WATCH BEFORE DELETED", "EXCLUSIVE DRAMA", "TRENDING NOW", "MOST WATCHED DRAMA",
            "SHOCKING ENDING", "ROMANTIC DRAMA", "MUST WATCH TODAY", "VIRAL KOREAN SERIES",
            "ENGLISH SUBTITLES", "WATCH WITH SUBS", "HD QUALITY FREE", "BINGE WATCH NOW",
            "WATCH NOW", "ALL EPISODES", "FOR FREE", "DIVORCED AT THE WEDDING DAY",
            "VER GRATIS AHORA", "EPISODIOS GRATIS", "DORAMA COMPLETO", "√öLTIMO CAP√çTULO",
            "VER AHORA GRATIS", "TODOS LOS EPISODIOS", "TOCA PARA VER", "NUEVO DORAMA",
            "VER ANTES QUE BORREN", "DORAMA EXCLUSIVO", "LO M√ÅS VISTO", "DRAMA COREANO",
            "FINAL IMPACTANTE", "DORAMA ROM√ÅNTICO", "M√çRALO HOY", "SERIE VIRAL",
            "SUBT√çTULOS ESPA√ëOL", "CON SUBT√çTULOS", "CALIDAD HD GRATIS", "MARAT√ìN GRATIS",
            "ROMANCE DRAMA FREE", "ACTION KDRAMA", "MEDICAL DRAMA", "SCHOOL ROMANCE",
            "DORAMA DE AMOR", "ACCI√ìN COREANA", "DRAMA M√âDICO", "ROMANCE ESCOLAR"
        ];

        const defaultTemplates = {
            kdrama_romantic: { 
                name: 'K-Drama Rom√¢ntico', 
                settings: { 
                    brightness: 105, contrast: 110, saturate: 115, 
                    headlineFont: 'Default', headlineBackgroundStyle: 'capsule', 
                    headlineBackgroundColor: '#FF1493', headlineBackgroundOpacity: 0.85, 
                    headlineColor: '#FFFFFF' 
                }
            },
            kdrama_suspense: { 
                name: 'K-Drama Suspense', 
                settings: { 
                    brightness: 90, contrast: 120, saturate: 85, 
                    headlineFont: 'Impact', headlineBackgroundStyle: 'faixa', 
                    headlineBackgroundColor: '#000000', headlineBackgroundOpacity: 0.9, 
                    headlineColor: '#FFFFFF' 
                }
            },
            kdrama_trending: { 
                name: 'K-Drama Viral', 
                settings: { 
                    brightness: 110, contrast: 115, saturate: 125, 
                    headlineFont: 'Anton', headlineBackgroundStyle: 'faixa', 
                    headlineBackgroundColor: '#FF0000', headlineBackgroundOpacity: 1, 
                    headlineColor: '#FFFFFF' 
                }
            },
            dorama_espanol: { 
                name: 'Dorama Espa√±ol', 
                settings: { 
                    brightness: 105, contrast: 110, saturate: 120, 
                    headlineFont: 'Impact', headlineBackgroundStyle: 'capsule', 
                    headlineBackgroundColor: '#FFA500', headlineBackgroundOpacity: 0.9, 
                    headlineColor: '#000000' 
                }
            },
            netflix_style: { 
                name: 'Estilo Netflix', 
                settings: { 
                    brightness: 95, contrast: 115, saturate: 100, 
                    headlineFont: 'Default', headlineBackgroundStyle: 'faixa', 
                    headlineBackgroundColor: '#E50914', headlineBackgroundOpacity: 0.95, 
                    headlineColor: '#FFFFFF' 
                }
            },
            viki_style: { 
                name: 'Estilo Viki', 
                settings: { 
                    brightness: 100, contrast: 105, saturate: 110, 
                    headlineFont: 'Default', headlineBackgroundStyle: 'vazado', 
                    headlineBackgroundColor: '#00D4FF', headlineBackgroundOpacity: 0.8, 
                    headlineColor: '#FFFFFF' 
                }
            },
            watch_now_style: {
                name: 'Watch Now Premium',
                settings: {
                    brightness: 105, contrast: 115, saturate: 110,
                    headlineFont: 'Anton', headlineBackgroundStyle: 'faixa',
                    headlineBackgroundColor: '#FFD700', headlineBackgroundOpacity: 0.9,
                    headlineColor: '#000000',
                    filter: 'dramatic'
                }
            }
        };

        const FILTERS = {
            'none': { name: 'Nenhum', value: '' },
            'kdrama': { name: 'K-Drama', value: 'contrast(1.1) saturate(1.3) brightness(1.05) sepia(0.1)' },
            'romantic': { name: 'Rom√¢ntico', value: 'contrast(1.05) saturate(1.4) brightness(1.1) hue-rotate(-5deg)' },
            'dramatic': { name: 'Dram√°tico', value: 'contrast(1.4) brightness(0.85) saturate(1.2)' },
            'vintage': { name: 'Vintage', value: 'sepia(0.3) contrast(1.2) brightness(0.95) saturate(1.2)' },
            'cinematic': { name: 'Cinem√°tico', value: 'contrast(1.3) saturate(1.4) brightness(0.8)' },
            'emotional': { name: 'Emocional', value: 'contrast(1.2) saturate(0.8) brightness(0.95) sepia(0.15)' },
            'vibrant': { name: 'Vibrante', value: 'saturate(1.8) contrast(1.1) brightness(1.05)' },
            'soft': { name: 'Suave', value: 'contrast(0.95) saturate(1.2) brightness(1.1) blur(0.3px)' }
        };

        // --- Inicializa√ß√£o ---
        function initializeApp() {
            setCanvasSize('story');
            initializeHeadlineButtons();
            renderFilters();
            loadCustomTemplates();
            loadDeletedDefaultTemplates();
            renderAllTemplates();
            loadSavedLogos();
        }

        // --- Event Listeners ---
        galleryContainer.addEventListener('click', (e) => {
            const item = e.target.closest('.gallery-item');
            if (!item) return;

            const id = parseInt(item.dataset.id);
            const action = e.target.dataset.action;

            if (action === 'delete') {
                e.stopPropagation();
                deleteImage(id);
            } else { // Clicar em qualquer lugar do item seleciona
                selectImage(id);
            }
        });

        uploadArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files));

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragging'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragging'), false);
        });
        uploadArea.addEventListener('drop', handleDrop, false);

        document.getElementById('fill-mode-controls').addEventListener('click', (e) => handleControlClick(e, 'data-mode', (newMode) => {
            updateActiveImageProp('fillMode', newMode);
            redrawCanvas();
            updateUI();
        }));

        document.getElementById('play-button-controls').addEventListener('click', (e) => handleControlClick(e, 'data-type', (newType) => {
            updateActiveImageProp('selectedPlayButton', newType);
            redrawCanvas();
            updateUI();
        }, 'visual-btn'));

        document.getElementById('text-background-controls').addEventListener('click', (e) => handleControlClick(e, 'data-style', (newStyle) => {
            updateActiveImageProp('headlineBackgroundStyle', newStyle);
            redrawCanvas();
            updateUI();
        }));

        document.getElementById('format-controls').addEventListener('click', (e) => handleControlClick(e, 'data-format', (newFormat) => {
            updateActiveImageProp('selectedFormat', newFormat);
            updateUI();
        }));

        document.getElementById('font-family-controls').addEventListener('click', (e) => handleControlClick(e, 'data-font', (newFont) => {
            updateActiveImageProp('headlineFont', newFont);
            redrawCanvas();
            updateUI();
        }));

        templateControls.addEventListener('click', (e) => handleTemplateClick(e));
        customTemplatesContainer.addEventListener('click', (e) => handleTemplateClick(e));

        headlineButtonsContainer.addEventListener('click', (e) => handleControlClick(e, 'data-text', (newText) => {
            updateActiveImageProp('headlineText', newText);
            customHeadlineInput.value = '';
            redrawCanvas();
            updateUI();
        }, 'headline-btn'));

        customHeadlineInput.addEventListener('input', (e) => {
            updateActiveImageProp('headlineText', e.target.value);
            redrawCanvas();
            document.querySelectorAll('#headline-buttons-container .headline-btn').forEach(btn => btn.classList.remove('active'));
        });

        removeTextBtn.addEventListener('click', () => {
            updateActiveImageProp('headlineText', '');
            customHeadlineInput.value = '';
            redrawCanvas();
            updateUI();
        });

        textColorPicker.addEventListener('input', (e) => {
            updateActiveImageProp('headlineColor', e.target.value);
            redrawCanvas();
        });

        fontSizeSlider.addEventListener('input', (e) => {
            updateActiveImageProp('headlineSize', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });

        qualitySlider.addEventListener('input', (e) => {
            updateActiveImageProp('quality', parseInt(e.target.value));
            updateUI();
        });

        textBgColorPicker.addEventListener('input', (e) => {
            updateActiveImageProp('headlineBackgroundColor', e.target.value);
            redrawCanvas();
        });

        textBgOpacitySlider.addEventListener('input', (e) => {
            const opacityValue = parseInt(e.target.value);
            updateActiveImageProp('headlineBackgroundOpacity', opacityValue / 100);
            redrawCanvas();
            updateUI();
        });

        playButtonSizeSlider.addEventListener('input', (e) => {
            updateActiveImageProp('playButtonSize', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });

        brightnessSlider.addEventListener('input', (e) => {
            updateActiveImageProp('brightness', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });

        contrastSlider.addEventListener('input', (e) => {
            updateActiveImageProp('contrast', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });

        saturateSlider.addEventListener('input', (e) => {
            updateActiveImageProp('saturate', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });

        resetImageAdjustmentsBtn.addEventListener('click', () => {
            updateActiveImageProp('brightness', 100);
            updateActiveImageProp('contrast', 100);
            updateActiveImageProp('saturate', 100);
            redrawCanvas();
            updateUI();
        });

        resetPlayButtonBtn.addEventListener('click', () => {
            updateActiveImageProp('playButtonSize', 120);
            redrawCanvas();
            updateUI();
        });

        const imageScaleSlider = document.getElementById('image-scale-slider');
        const imageXSlider = document.getElementById('image-x-slider');
        const imageYSlider = document.getElementById('image-y-slider');
        const resetTransformBtn = document.getElementById('reset-transform-btn');
        const centerImageBtn = document.getElementById('center-image-btn');
        const fitImageBtn = document.getElementById('fit-image-btn');

        if (imageScaleSlider) {
            imageScaleSlider.addEventListener('input', (e) => {
                updateActiveImageProp('imageScale', parseInt(e.target.value));
                redrawCanvas();
                updateUI();
            });
        }

        if (imageXSlider) {
            imageXSlider.addEventListener('input', (e) => {
                updateActiveImageProp('imageX', parseInt(e.target.value));
                redrawCanvas();
                updateUI();
            });
        }

        if (imageYSlider) {
            imageYSlider.addEventListener('input', (e) => {
                updateActiveImageProp('imageY', parseInt(e.target.value));
                redrawCanvas();
                updateUI();
            });
        }

        if (resetTransformBtn) {
            resetTransformBtn.addEventListener('click', () => {
                updateActiveImageProp('imageScale', 100);
                updateActiveImageProp('imageX', 0);
                updateActiveImageProp('imageY', 0);
                redrawCanvas();
                updateUI();
            });
        }

        if (centerImageBtn) {
            centerImageBtn.addEventListener('click', () => {
                updateActiveImageProp('imageX', 0);
                updateActiveImageProp('imageY', 0);
                redrawCanvas();
                updateUI();
            });
        }

        if (fitImageBtn) {
            fitImageBtn.addEventListener('click', () => {
                fitImageToCanvas();
            });
        }
        
        // Fun√ß√£o para ajustar imagem ao canvas
        function fitImageToCanvas() {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage || !activeImage.imageObj) return;
            
            const canvasAspectRatio = TARGET_WIDTH / TARGET_HEIGHT;
            const imgAspectRatio = activeImage.imageObj.width / activeImage.imageObj.height;
            
            let scale;
            if (canvasAspectRatio > imgAspectRatio) {
                // Imagem √© mais alta proporcionalmente
                scale = (TARGET_HEIGHT / activeImage.imageObj.height) * 100;
            } else {
                // Imagem √© mais larga proporcionalmente
                scale = (TARGET_WIDTH / activeImage.imageObj.width) * 100;
            }
            
            updateActiveImageProp('imageScale', Math.min(scale, 200));
            updateActiveImageProp('imageX', 0);
            updateActiveImageProp('imageY', 0);
            redrawCanvas();
            updateUI();
        }

        clearGalleryBtn.addEventListener('click', clearGallery);
        saveTemplateBtn.addEventListener('click', saveNewTemplate);
        resetTemplatesBtn.addEventListener('click', resetDefaultTemplates);

        processBtn.addEventListener('click', processImage);
        generateVariationsBtn.addEventListener('click', generateAutomaticVariations);
        batchProcessBtn.addEventListener('click', processBatch);

        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                document.querySelectorAll('.control-section').forEach(s => s.classList.remove('active'));
                const panel = document.getElementById(btn.dataset.panel);
                if (panel) {
                    panel.classList.add('active');
                }
            });
        });

        uploadLogoBtn.addEventListener('click', () => logoFileInput.click());
        logoFileInput.addEventListener('change', (e) => handleLogoUpload(e.target.files));
        logoGalleryContainer.addEventListener('click', handleLogoGalleryClick);
        logoScaleSlider.addEventListener('input', (e) => {
            updateActiveImageProp('logoScale', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });
        removeLogoBtn.addEventListener('click', () => {
            updateActiveImageProp('activeLogoId', null);
            redrawCanvas();
            updateUI();
        });

        outputCanvas.addEventListener('mousedown', handleMouseDown);
        outputCanvas.addEventListener('mousemove', handleMouseMove);
        outputCanvas.addEventListener('mouseup', handleMouseUp);
        outputCanvas.addEventListener('mouseleave', handleMouseUp);

        formatSelector.addEventListener('click', (e) => {
            const button = e.target.closest('button');
            if (button && button.dataset.size) {
                setCanvasSize(button.dataset.size);
            }
        });

        filtersContainer.addEventListener('click', (e) => {
            const item = e.target.closest('.filter-item');
            if (item && item.dataset.filter) {
                const filterKey = item.dataset.filter;
                updateActiveImageProp('filter', filterKey);
                redrawCanvas();
                renderFilters();
            }
        });

        resetFiltersBtn.addEventListener('click', () => {
            updateActiveImageProp('filter', 'none');
            redrawCanvas();
            renderFilters();
        });

        // Event listener para o slider de tamanho dos elementos de dorama
        doramaElementsSizeSlider.addEventListener('input', (e) => {
            doramaElementsSize = parseInt(e.target.value);
            doramaElementsSizeValue.textContent = `${doramaElementsSize}%`;
            redrawCanvas();
        });

        // Event listener para o seletor de cor dos badges
        doramaBadgeColorPicker.addEventListener('input', (e) => {
            const activeTypes = Object.keys(doramaElements).filter(type => doramaElements[type] !== null);
            activeTypes.forEach(type => {
                doramaBadgeColors[type] = e.target.value;
            });
            redrawCanvas();
        });

        // Bot√£o "Cores Padr√£o" dos badges
        const resetBadgeColorsBtn = document.getElementById('reset-badge-colors-btn');
        if (resetBadgeColorsBtn) {
            resetBadgeColorsBtn.addEventListener('click', () => {
                const defaultColor = doramaBadgeColorPicker && doramaBadgeColorPicker.defaultValue ? doramaBadgeColorPicker.defaultValue : '#FF0000';
                const activeTypes = Object.keys(doramaElements).filter(type => doramaElements[type] !== null);
                activeTypes.forEach(type => {
                    doramaBadgeColors[type] = defaultColor;
                });
                if (doramaBadgeColorPicker) doramaBadgeColorPicker.value = defaultColor;
                redrawCanvas();
            });
        }

        // Atalhos de teclado
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        if (!isProcessing && activeImageId !== null) {
                            processImage();
                        }
                        break;
                    case 'g':
                        e.preventDefault();
                        if (!isProcessing && activeImageId !== null) {
                            generateAutomaticVariations();
                        }
                        break;
                    case 'b':
                        e.preventDefault();
                        if (!isProcessing && uploadedImages.length > 0) {
                            processBatch();
                        }
                        break;
                    case 'Delete':
                        if (activeImageId !== null) {
                            deleteImage(activeImageId);
                        }
                        break;
                }
            }
            
            // Navega√ß√£o entre imagens com setas
            if (activeImageId !== null && !e.ctrlKey && !e.metaKey) {
                const currentIndex = uploadedImages.findIndex(img => img.id === activeImageId);
                if (e.key === 'ArrowLeft' && currentIndex > 0) {
                    selectImage(uploadedImages[currentIndex - 1].id);
                } else if (e.key === 'ArrowRight' && currentIndex < uploadedImages.length - 1) {
                    selectImage(uploadedImages[currentIndex + 1].id);
                }
            }
        });

        // --- Fun√ß√µes Principais ---
        function setCanvasSize(size) {
            if (size === 'square') {
                TARGET_WIDTH = 1024;
                TARGET_HEIGHT = 1024;
                canvasWrapper.style.aspectRatio = '1 / 1';
                canvasWrapper.style.maxWidth = '600px';
            } else if (size === 'feed') {
                TARGET_WIDTH = 1080;
                TARGET_HEIGHT = 1350;
                canvasWrapper.style.aspectRatio = '4 / 5';
                canvasWrapper.style.maxWidth = '480px';
            } else if (size === 'vertical') {
                TARGET_WIDTH = 1024;
                TARGET_HEIGHT = 1536;
                canvasWrapper.style.aspectRatio = '2 / 3';
                canvasWrapper.style.maxWidth = '400px';
            } else { // Default to 'story'
                TARGET_WIDTH = 1080;
                TARGET_HEIGHT = 1920;
                canvasWrapper.style.aspectRatio = '9 / 16';
                canvasWrapper.style.maxWidth = '405px';
            }

            outputCanvas.width = TARGET_WIDTH;
            outputCanvas.height = TARGET_HEIGHT;

            formatSelector.querySelectorAll('button').forEach(btn => {
                const isSelected = btn.dataset.size === size;
                btn.classList.toggle('btn-primary', isSelected);
                btn.classList.toggle('btn-secondary', !isSelected);
            });
            
            requestRedraw();
        }

        // Delega√ß√£o de eventos para bot√µes do painel de elementos (corrige onclicks que quebraram)
        const elementsPanel = document.getElementById('elements-panel');
        if (elementsPanel) {
            elementsPanel.addEventListener('click', (e) => {
                const btn = e.target.closest('button[data-dorama]');
                if (!btn) return;
                const type = btn.getAttribute('data-dorama');
                toggleDoramaElement(type);
                // Atualiza estado visual
                btn.classList.toggle('active', doramaElements[type] !== null);
            });
        }

        function initializeHeadlineButtons() {
            headlineSourceList = defaultHeadlines;
            headlineButtonsContainer.innerHTML = '';
            headlineSourceList.forEach((text) => {
                const button = document.createElement('button');
                button.className = 'headline-btn';
                button.textContent = text;
                button.dataset.text = text;
                headlineButtonsContainer.appendChild(button);
            });
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            preventDefaults(e);
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFileSelect(files);
        }

        function handleFileSelect(files) {
            if (files.length === 0) return;
            
            let filesToLoad = Array.from(files).filter(file => file.type.startsWith('image/')).length;
            if (filesToLoad === 0) return;
            
            for(const file of files) {
                if (!file.type.startsWith('image/')) {
                    showNotification(`'${file.name}' n√£o √© uma imagem.`, 'error');
                    continue;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const newImage = {
                        id: imageIdCounter++,
                        name: file.name,
                        dataURL: e.target.result,
                        imageObj: null,
                        imageColors: null,
                        composition: null,
                        filter: 'none',
                        fillMode: 'blur-pro',
                        blurAmount: 40,
                        solidFillColor: '#000000',
                        brightness: 100,
                        contrast: 100,
                        saturate: 100,
                        headlineText: defaultHeadlines[0],
                        headlineFont: 'Default',
                        headlineColor: '#FFFFFF',
                        headlineSize: 80,
                        headlineBackgroundStyle: 'faixa',
                        headlineBackgroundColor: '#000000',
                        headlineBackgroundOpacity: 0.6,
                        headlineX: 50,
                        headlineY: 85,
                        selectedPlayButton: 'none',
                        playButtonSize: 120,
                        playButtonX: 50,
                        playButtonY: 50,
                        imageScale: 100,
                        imageX: 0,
                        imageY: 0,
                        selectedFormat: 'jpeg',
                        quality: 85
                    };
                    
                    uploadedImages.push(newImage);
                    
                    filesToLoad--;
                    if (filesToLoad === 0) {
                        if (activeImageId === null && uploadedImages.length > 0) {
                            // Primeira carga: selecione a √∫ltima imagem adicionada
                            selectImage(uploadedImages[uploadedImages.length - 1].id);
                        } else {
                            // J√° havia uma imagem ativa: apenas atualize a galeria
                            renderGallery();
                        }
                    }
                };
                reader.readAsDataURL(file);
            }
        }

        function renderGallery() {
            galleryContainer.innerHTML = '';
            uploadedImages.forEach(image => {
                const itemContainer = document.createElement('div');
                itemContainer.className = 'gallery-item';
                itemContainer.title = image.name;
                itemContainer.dataset.id = image.id;

                const thumb = document.createElement('div');
                thumb.className = 'gallery-thumbnail';
                thumb.style.backgroundImage = `url(${image.dataURL})`;
                
                if (image.id === activeImageId) {
                    thumb.classList.add('active');
                }

                const nameEl = document.createElement('p');
                nameEl.className = 'gallery-name';
                nameEl.textContent = image.name;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.dataset.action = 'delete';

                itemContainer.appendChild(deleteBtn);
                itemContainer.appendChild(thumb);
                itemContainer.appendChild(nameEl);
                galleryContainer.appendChild(itemContainer);
            });
        }
        
        // An√°lise b√°sica de cores (fallback leve para evitar travar carregamento)
        async function analyzeImageColors(img, quick = true) {
            try {
                const sampleW = 120;
                const aspect = img.width / img.height;
                const w = sampleW;
                const h = Math.max(1, Math.round(sampleW / (aspect || 1)));
                const canv = document.createElement('canvas');
                const cctx = canv.getContext('2d');
                canv.width = w;
                canv.height = h;
                cctx.drawImage(img, 0, 0, w, h);
                const data = cctx.getImageData(0, 0, w, h).data;

                let rSum = 0, gSum = 0, bSum = 0, n = 0;
                let rTop = 0, gTop = 0, bTop = 0, nTop = 0;
                let rBot = 0, gBot = 0, bBot = 0, nBot = 0;
                const quantize = (v) => Math.min(255, Math.max(0, Math.round(v / 16) * 16));
                const paletteMap = new Map();

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const idx = (y * w + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        rSum += r; gSum += g; bSum += b; n++;
                        if (y < h / 3) { rTop += r; gTop += g; bTop += b; nTop++; }
                        if (y >= (2 * h) / 3) { rBot += r; gBot += g; bBot += b; nBot++; }
                        const qr = quantize(r), qg = quantize(g), qb = quantize(b);
                        const key = `${qr},${qg},${qb}`;
                        paletteMap.set(key, (paletteMap.get(key) || 0) + 1);
                    }
                }

                const avg = [Math.round(rSum / n), Math.round(gSum / n), Math.round(bSum / n)];
                const top = nTop ? [Math.round(rTop / nTop), Math.round(gTop / nTop), Math.round(bTop / nTop)] : avg;
                const bottom = nBot ? [Math.round(rBot / nBot), Math.round(gBot / nBot), Math.round(bBot / nBot)] : avg;

                // Top N cores mais frequentes
                const palette = Array.from(paletteMap.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 8)
                    .map(([k]) => k.split(',').map(v => parseInt(v, 10)));

                return {
                    dominant: avg,
                    top,
                    bottom,
                    palette
                };
            } catch (err) {
                // Fallback defensivo
                return {
                    dominant: [40, 40, 40],
                    top: [40, 40, 40],
                    bottom: [40, 40, 40],
                    palette: [[40, 40, 40]]
                };
            }
        }

        // An√°lise b√°sica de composi√ß√£o (fallback leve)
        async function analyzeImageComposition(img) {
            // Heur√≠stica simples: usa propor√ß√£o da imagem como "aspectRatio do sujeito"
            // e assume √°rea central ocupando ~45%.
            const aspect = img.width && img.height ? (img.width / img.height) : 1;
            return {
                subjectBox: {
                    areaRatio: 0.45,
                    aspectRatio: aspect
                }
            };
        }

        async function selectImage(id) {
            const selectedImage = uploadedImages.find(img => img.id === id);
            if (!selectedImage || activeImageId === id) return;

            activeImageId = id;

            if (!selectedImage.imageObj) {
                showNotification(`Carregando '${selectedImage.name}'...`, 'success');
                selectedImage.imageObj = new Image();
                await new Promise((resolve, reject) => {
                    selectedImage.imageObj.onload = resolve;
                    selectedImage.imageObj.onerror = reject;
                    selectedImage.imageObj.src = selectedImage.dataURL;
                });
                selectedImage.imageColors = await analyzeImageColors(selectedImage.imageObj, true);
                selectedImage.composition = await analyzeImageComposition(selectedImage.imageObj);
            }
            
            updateUI();
            redrawCanvas();
            renderGallery();
        }

        function deleteImage(id) {
            const index = uploadedImages.findIndex(img => img.id === id);
            if (index === -1) return;

            uploadedImages.splice(index, 1);
            
            if (activeImageId === id) {
                activeImageId = null;
                if (uploadedImages.length > 0) {
                    const newIndex = Math.max(0, Math.min(index, uploadedImages.length - 1));
                    selectImage(uploadedImages[newIndex].id);
                } else {
                    redrawCanvas();
                    renderGallery();
                    updateUI();
                }
            } else {
                renderGallery();
            }
        }

        function clearGallery() {
            uploadedImages = [];
            activeImageId = null;
            imageIdCounter = 0;
            renderGallery();
            redrawCanvas();
            updateUI();
        }

        function updateActiveImageProp(prop, value) {
            if (activeImageId === null) return;
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (activeImage) {
                activeImage[prop] = value;
            }
        }

        function updateUI() {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            
            if (!activeImage) {
                // Reset UI to a default state if no image is selected
                document.querySelectorAll('.control-btn.active, .visual-btn.active, .headline-btn.active').forEach(el => el.classList.remove('active'));
                logoControls.classList.add('hidden');
                return;
            }

            document.querySelectorAll('#fill-mode-controls .control-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.mode === activeImage.fillMode));
            document.querySelectorAll('#play-button-controls .visual-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.type === activeImage.selectedPlayButton));
            document.querySelectorAll('#text-background-controls .control-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.style === activeImage.headlineBackgroundStyle));
            document.querySelectorAll('#format-controls .control-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.format === activeImage.selectedFormat));
            document.querySelectorAll('#font-family-controls .control-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.font === activeImage.headlineFont));
            
            const isCustomText = !defaultHeadlines.includes(activeImage.headlineText);
            document.querySelectorAll('#headline-buttons-container .headline-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.text === activeImage.headlineText && !isCustomText));
            
            customHeadlineInput.value = isCustomText ? activeImage.headlineText : '';

            fontSizeSlider.value = activeImage.headlineSize;
            fontSizeValue.textContent = `${activeImage.headlineSize}px`;
            qualitySlider.value = activeImage.quality;
            qualityValue.textContent = `${activeImage.quality}%`;
            textBgOpacitySlider.value = activeImage.headlineBackgroundOpacity * 100;
            textBgOpacityValue.textContent = `${Math.round(activeImage.headlineBackgroundOpacity * 100)}%`;
            playButtonSizeSlider.value = activeImage.playButtonSize;
            playButtonSizeValue.textContent = `${activeImage.playButtonSize}px`;
            brightnessSlider.value = activeImage.brightness;
            brightnessValue.textContent = `${activeImage.brightness}%`;
            contrastSlider.value = activeImage.contrast;
            contrastValue.textContent = `${activeImage.contrast}%`;
            saturateSlider.value = activeImage.saturate;
            saturateValue.textContent = `${activeImage.saturate}%`;
            
            // Atualizar controles de redimensionamento manual
            const imageScaleSlider = document.getElementById('image-scale-slider');
            const imageScaleValue = document.getElementById('image-scale-value');
            const imageXSlider = document.getElementById('image-x-slider');
            const imageXValue = document.getElementById('image-x-value');
            const imageYSlider = document.getElementById('image-y-slider');
            const imageYValue = document.getElementById('image-y-value');
            
            if (imageScaleSlider && imageScaleValue) {
                imageScaleSlider.value = activeImage.imageScale || 100;
                imageScaleValue.textContent = `${activeImage.imageScale || 100}%`;
            }
            
            if (imageXSlider && imageXValue) {
                imageXSlider.value = activeImage.imageX || 0;
                imageXValue.textContent = `${activeImage.imageX || 0}px`;
            }
            
            if (imageYSlider && imageYValue) {
                imageYSlider.value = activeImage.imageY || 0;
                imageYValue.textContent = `${activeImage.imageY || 0}px`;
            }

            textColorPicker.value = activeImage.headlineColor;
            textBgColorPicker.value = activeImage.headlineBackgroundColor;
            
            renderFillModeOptions();
            renderFilters();
            renderLogoGallery();

            logoControls.classList.toggle('hidden', activeImage.activeLogoId === null);
            if (activeImage.activeLogoId !== null) {
                logoScaleSlider.value = activeImage.logoScale;
                logoScaleValue.textContent = `${activeImage.logoScale}%`;
            }
        }

        function renderFillModeOptions() {
            fillModeOptionsContainer.innerHTML = '';
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage) return;
            
            if (activeImage.fillMode === 'blur-pro') {
                fillModeOptionsContainer.innerHTML = `
                    <div class="slider-container" style="margin-top: 0;">
                        <div class="slider-label">
                            <label for="blur-amount-slider">Intensidade do Desfoque</label>
                            <span id="blur-amount-value">${activeImage.blurAmount}px</span>
                        </div>
                        <input type="range" id="blur-amount-slider" min="10" max="120" value="${activeImage.blurAmount}">
                    </div>
                `;
                const blurSlider = document.getElementById('blur-amount-slider');
                const blurValue = document.getElementById('blur-amount-value');
                blurSlider.addEventListener('input', (e) => {
                    const val = parseInt(e.target.value);
                    blurValue.textContent = `${val}px`;
                    updateActiveImageProp('blurAmount', val);
                    redrawCanvas();
                });
            } else if (activeImage.fillMode === 'solid') {
                fillModeOptionsContainer.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <label>Cor de Fundo</label>
                        <input type="color" id="solid-fill-color-picker" value="${activeImage.solidFillColor}">
                    </div>
                `;
                const solidColorPicker = document.getElementById('solid-fill-color-picker');
                solidColorPicker.addEventListener('input', (e) => {
                    updateActiveImageProp('solidFillColor', e.target.value);
                    redrawCanvas();
                });
            } else if (activeImage.fillMode === 'smart') {
                const resolved = activeImage.smartFillCache && activeImage.smartFillCache.mode ? activeImage.smartFillCache.mode : 'calculando...';
                fillModeOptionsContainer.innerHTML = `
                    <div style="display:flex; align-items:center; gap:0.75rem; flex-wrap:wrap;">
                        <span style="font-size:0.9rem; color: var(--text-secondary);">Modo escolhido: <strong>${resolved}</strong></span>
                        <button id="recompute-smart-fill" class="btn btn-secondary">Recalcular</button>
                    </div>
                `;
                const recomputeBtn = document.getElementById('recompute-smart-fill');
                recomputeBtn.addEventListener('click', () => {
                    if (activeImage.smartFillCache) activeImage.smartFillCache = null;
                    redrawCanvas();
                    updateUI();
                });
            }
        }

        function handleControlClick(e, dataAttribute, callback, buttonClass = 'control-btn') {
            const button = e.target.closest(`.${buttonClass}`);
            if (!button) return;
            const value = button.getAttribute(dataAttribute);
            // Alterna estado visual: remove 'active' dos irm√£os dentro do mesmo container
            const container = button.parentElement;
            if (container) {
                const peers = container.querySelectorAll(`.${buttonClass}`);
                peers.forEach(b => b.classList.remove('active'));
            }
            button.classList.add('active');
            if (typeof callback === 'function') callback(value, button);
        }

        function drawBackground(image) {
            const img = image.imageObj;
            const imgAspectRatio = img.width / img.height;
            const canvasAspectRatio = TARGET_WIDTH / TARGET_HEIGHT;
            let bgWidth, bgHeight, bgX, bgY;

            if (imgAspectRatio > canvasAspectRatio) {
                bgHeight = TARGET_HEIGHT;
                bgWidth = bgHeight * imgAspectRatio;
                bgX = (TARGET_WIDTH - bgWidth) / 2;
                bgY = 0;
            } else {
                bgWidth = TARGET_WIDTH;
                bgHeight = bgWidth / imgAspectRatio;
                bgX = 0;
                bgY = (TARGET_HEIGHT - bgHeight) / 2;
            }

            // Preparar filtros compostos para modos de preenchimento
            const presetFilter = FILTERS[image.filter] ? FILTERS[image.filter].value : '';
            const brightness = `brightness(${(image.brightness || 100) / 100})`;
            const contrast = `contrast(${(image.contrast || 100) / 100})`;
            const saturate = `saturate(${(image.saturate || 100) / 100})`;
            const composedFilter = [presetFilter, brightness, contrast, saturate].filter(Boolean).join(' ').trim();

            switch (image.fillMode) {
        case 'blur-pro':
            // Desenha fundo desfocado nas bordas, mantendo √°rea central para imagem n√≠tida
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            const blurFilter = `blur(${image.blurAmount || 40}px)`;
            ctx.filter = composedFilter ? `${blurFilter} ${composedFilter}` : blurFilter;
            ctx.drawImage(img, bgX, bgY, bgWidth, bgHeight);
            ctx.restore();
            break;
        case 'edge-extend':
            // Preenchimento suave usando blur leve nas bordas
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Usar blur muito sutil (15px) para preenchimento suave
            const edgeBlur = `blur(15px)`;
            ctx.filter = composedFilter ? `${edgeBlur} ${composedFilter}` : edgeBlur;
            ctx.drawImage(img, bgX, bgY, bgWidth, bgHeight);
            
            ctx.restore();
            break;
        case 'stretch':
            // Estica a imagem para preencher todo o canvas
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            if (composedFilter) ctx.filter = composedFilter;
            ctx.drawImage(img, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            ctx.restore();
            break;
        case 'duotone':
            // Cria efeito duotone usando as cores da imagem
            if (image.imageColors && image.imageColors.dominant) {
                const [r, g, b] = image.imageColors.dominant;
                const brightness = (r + g + b) / 3;
                const shadowColor = brightness > 128 ? '#000000' : '#FFFFFF';
                const highlightColor = `rgb(${r}, ${g}, ${b})`;
                
                ctx.save();
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                if (composedFilter) ctx.filter = composedFilter;
                ctx.drawImage(img, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = shadowColor;
                ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = highlightColor;
                ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                ctx.restore();
            } else {
                // Fallback para stretch se n√£o houver cores analisadas
                ctx.save();
                if (composedFilter) ctx.filter = composedFilter;
                ctx.drawImage(img, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                ctx.restore();
            }
            break;
        case 'mosaic':
            // Cria efeito mosaico repetindo a imagem em escala reduzida
            const tileSize = Math.min(TARGET_WIDTH, TARGET_HEIGHT) / 8;
            const tilesX = Math.ceil(TARGET_WIDTH / tileSize);
            const tilesY = Math.ceil(TARGET_HEIGHT / tileSize);
            
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            if (composedFilter) ctx.filter = composedFilter;
            ctx.globalAlpha = 0.3;
            for (let x = 0; x < tilesX; x++) {
                for (let y = 0; y < tilesY; y++) {
                    ctx.drawImage(img, x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }
            ctx.restore();
            break;
        case 'gradient':
            const g = ctx.createLinearGradient(0, 0, 0, TARGET_HEIGHT);
            g.addColorStop(0, `rgb(${image.imageColors.top.join(',')})`);
            g.addColorStop(1, `rgb(${image.imageColors.bottom.join(',')})`);
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            break;
        case 'solid':
            ctx.fillStyle = image.solidFillColor;
            ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            break;
        case 'smart': {
            // Resolver melhor modo via heur√≠stica com cache
            const resolved = computeSmartFill(image);
            // Desenhar usando o modo resolvido sem alterar estado permanente do UI
            const original = image.fillMode;
            image.fillMode = resolved.mode;
            // Aplicar par√¢metros resolvidos temporariamente
            const saved = { blurAmount: image.blurAmount, solidFillColor: image.solidFillColor };
            if (resolved.params) {
                if (typeof resolved.params.blurAmount === 'number') image.blurAmount = resolved.params.blurAmount;
                if (typeof resolved.params.solidFillColor === 'string') image.solidFillColor = resolved.params.solidFillColor;
            }
            // Chamada recursiva controlada
            drawBackground(image);
            // Restaurar estado
            image.fillMode = original;
            image.blurAmount = saved.blurAmount;
            image.solidFillColor = saved.solidFillColor;
            break;
        }
            }
        }

// Heur√≠stica para escolher o melhor preenchimento de borda
function computeSmartFill(image) {
    // Cache: refaz apenas quando mudar dimens√µes ou cores/composi√ß√£o
    const version = JSON.stringify({
        w: TARGET_WIDTH,
        h: TARGET_HEIGHT,
        colors: image.imageColors || null,
        comp: image.composition || null
    });
    if (image.smartFillCache && image.smartFillCache.version === version) {
        return image.smartFillCache;
    }

    const colors = image.imageColors || {};
    const dominant = colors.dominant || [40, 40, 40];
    const top = colors.top || dominant;
    const bottom = colors.bottom || dominant;

    // Sinais simples de decis√£o
    const paletteSize = Array.isArray(colors.palette) ? colors.palette.length : 0;
    const comp = image.composition || {};
    const subject = comp.subjectBox || {};
    const subjectArea = typeof subject.areaRatio === 'number' ? subject.areaRatio : null; // 0..1
    const subjectNarrow = typeof subject.aspectRatio === 'number' ? (subject.aspectRatio < 0.6 || subject.aspectRatio > 1.8) : false;

    // Heur√≠sticas b√°sicas
    let mode = 'blur-pro';
    let params = {};

    // 1) Se paleta pequena ou alto contraste ‚Üí duotone/gradient
    if (paletteSize && paletteSize <= 3) {
        mode = 'duotone';
    } else if (paletteSize && paletteSize <= 5) {
        mode = 'gradient';
    }

    // 2) Se sujeito ocupa pouco espa√ßo ou √© estreito ‚Üí stretch ajuda a preencher
    if ((subjectArea !== null && subjectArea < 0.25) || subjectNarrow) {
        mode = 'stretch';
    }

    // 3) Se imagem muito detalhada (supor paleta grande) ‚Üí blur-pro mais forte
    if (paletteSize && paletteSize > 6) {
        mode = 'blur-pro';
        params.blurAmount = Math.min(80, Math.max(30, Math.round(0.06 * Math.max(TARGET_WIDTH, TARGET_HEIGHT))));
    }

    // 4) Fallback: se nada definido claramente, usar gradient com cores topo/base ou blur suave
    if (!mode) mode = 'gradient';

    // Par√¢metros auxiliares
    if (mode === 'solid') {
        // Usar cor s√≥lida aproximada dominante
        const [r, g, b] = dominant;
        params.solidFillColor = `#${[r, g, b].map(v => v.toString(16).padStart(2, '0')).join('')}`;
    }

    const result = { mode, params, version };
    image.smartFillCache = result;
    return result;
}
        

        // Desenha toda a composi√ß√£o no canvas
        // Pode ser chamado como redrawCanvas() ou redrawCanvas(image)
        function redrawCanvas(targetImage = null) {
            // Resolver imagem ativa
            const image = targetImage || uploadedImages.find(img => img.id === activeImageId);

            // Limpar canvas
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.globalAlpha = 1;
            ctx.filter = 'none';
            ctx.clearRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            ctx.restore();

            if (!image || !image.imageObj) {
                // Nada a desenhar al√©m do fundo neutro
                return;
            }

            // 1) Fundo de preenchimento (bordas)
            drawBackground(image);

            // 2) Imagem principal com filtros e transforma√ß√µes (blur-pro permite imagem n√≠tida por cima)
            if (!['stretch', 'duotone', 'mosaic'].includes(image.fillMode)) {
                const img = image.imageObj;
                const imgAspectRatio = img.width / img.height;
                const canvasAspectRatio = TARGET_WIDTH / TARGET_HEIGHT;
                
                let mainW, mainH, mainX, mainY;
                
                // Para modos de preenchimento: imagem deve preencher a largura total
                if (['blur-pro', 'edge-extend', 'gradient', 'solid', 'smart'].includes(image.fillMode)) {
                    mainW = TARGET_WIDTH;
                    mainH = TARGET_WIDTH / imgAspectRatio;
                    mainX = 0;
                    mainY = (TARGET_HEIGHT - mainH) / 2;
                } else {
                    // Para outros modos: usar escala e posicionamento customiz√°vel
                    const scale = (image.imageScale || 100) / 100;
                    mainW = img.width * scale;
                    mainH = img.height * scale;
                    
                    // Interpreta√ß√£o: imageX/Y s√£o deslocamentos em px a partir do centro do canvas
                    const centerX = TARGET_WIDTH / 2 + (image.imageX || 0);
                    const centerY = TARGET_HEIGHT / 2 + (image.imageY || 0);
                    mainX = centerX - mainW / 2;
                    mainY = centerY - mainH / 2;
                }

                // Monta filtro composto (preset + ajustes manuais)
                const presetFilter = FILTERS[image.filter] ? FILTERS[image.filter].value : '';
                const brightness = `brightness(${(image.brightness || 100) / 100})`;
                const contrast = `contrast(${(image.contrast || 100) / 100})`;
                const saturate = `saturate(${(image.saturate || 100) / 100})`;
                const composedFilter = [presetFilter, brightness, contrast, saturate].filter(Boolean).join(' ').trim();

                ctx.save();
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                if (composedFilter) ctx.filter = composedFilter;
                ctx.drawImage(img, mainX, mainY, mainW, mainH);
                ctx.restore();
            }

            // 3) Overlays: texto, logotipo, bot√£o de play e badges de dorama
            drawTextElements(image);
            drawLogoOverlay(image);
            drawPlayButton(image);
            drawDoramaElements(image);

            // 4) Guias de snap (se ativo durante drag)
            if (snapStatus && (snapStatus.horizontal || snapStatus.vertical)) {
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 200, 120, 0.6)';
                ctx.lineWidth = 2;
                if (snapStatus.horizontal) {
                    const y = TARGET_HEIGHT / 2;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(TARGET_WIDTH, y);
                    ctx.stroke();
                }
                if (snapStatus.vertical) {
                    const x = TARGET_WIDTH / 2;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, TARGET_HEIGHT);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }
        

        function wrapText(context, text, maxWidth) {
            const words = text.split(' ');
            let line = '';
            let lines = [];

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = context.measureText(testLine);
                if (metrics.width > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line);
            return lines;
        }

        function drawTextElements(image) {
            if (!image.headlineText) return;
            ctx.save();
            const text = image.headlineText.toUpperCase();
            
            let fontFamily = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
            if (image.headlineFont === 'Impact') {
                fontFamily = "Impact, sans-serif";
            } else if (image.headlineFont === 'Anton') {
                fontFamily = "'Anton', sans-serif";
            }

            ctx.font = `bold ${image.headlineSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const { x, y, width, height } = getTextBoundingBox(image);

            if (image.headlineBackgroundStyle === 'faixa' || image.headlineBackgroundStyle === 'capsule') {
                const rgb = hexToRgb(image.headlineBackgroundColor);
                ctx.fillStyle = rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${image.headlineBackgroundOpacity})` : 'rgba(0, 0, 0, 0.6)';

                if (image.headlineBackgroundStyle === 'faixa') {
                    ctx.fillRect(0, y, TARGET_WIDTH, height);
                } else {
                    const radius = height / 2;
                    ctx.beginPath();
                    ctx.roundRect(x, y, width, height, radius);
                    ctx.fill();
                }
            }

            ctx.shadowColor = 'black';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;

            const lines = wrapText(ctx, text, TARGET_WIDTH - 80);
            const lineHeight = image.headlineSize * 1.2;
            let currentY = y + (height / 2) - ((lines.length - 1) * lineHeight / 2);

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                const textX = x + width / 2;
                if (image.headlineBackgroundStyle === 'vazado') {
                    ctx.strokeStyle = image.headlineColor;
                    ctx.lineWidth = 4;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(line, textX, currentY);
                } else {
                    ctx.fillStyle = image.headlineColor;
                    ctx.fillText(line, textX, currentY);
                }
                currentY += lineHeight;
            }
            ctx.restore();
        }

        // =================================================================
        // CORRE√á√ÉO APLICADA AQUI
        // =================================================================
        function drawPlayButton(image) {
            const type = image.selectedPlayButton;
            if (type === 'none') return;

            const size = image.playButtonSize;
            const { x, y, width, height } = getPlayButtonBoundingBox(image);
            const cX = x + width / 2;
            const cY = y + height / 2;
            const s = size; // shorthand for size

            ctx.save();
            ctx.shadowBlur = 0; // Reset shadow for buttons
            
            switch(type) {
                case 'youtube': {
                    ctx.fillStyle = '#FF0000';
                    const rectWidth = s * 0.9;
                    const rectHeight = s * 0.65;
                    ctx.beginPath();
                    ctx.roundRect(cX - rectWidth / 2, cY - rectHeight / 2, rectWidth, rectHeight, s * 0.15);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    const triangleHeight = s * 0.35;
                    const triangleBase = s * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(cX - triangleBase / 2 + s * 0.05, cY - triangleHeight / 2);
                    ctx.lineTo(cX - triangleBase / 2 + s * 0.05, cY + triangleHeight / 2);
                    ctx.lineTo(cX + triangleBase / 2 + s * 0.05, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }
                    
                case 'new-tiktok': {
                    ctx.fillStyle = '#00F2EA';
                    ctx.beginPath();
                    ctx.arc(cX + s * 0.08, cY - s * 0.08, s * 0.33, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FF0050';
                    ctx.beginPath();
                    ctx.arc(cX - s * 0.08, cY + s * 0.08, s * 0.33, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.29, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.08, cY - s * 0.15);
                    ctx.lineTo(cX - s * 0.08, cY + s * 0.15);
                    ctx.lineTo(cX + s * 0.12, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }
                
                case 'gradient-circle': {
                    const grad = ctx.createLinearGradient(cX - s/2, cY - s/2, cX + s/2, cY + s/2);
                    grad.addColorStop(0, "#8A2BE2");
                    grad.addColorStop(1, "#00BFFF");
                    
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = s * 0.08;
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.38, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.1, cY - s * 0.18);
                    ctx.lineTo(cX - s * 0.1, cY + s * 0.18);
                    ctx.lineTo(cX + s * 0.15, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'red-circle': {
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.42, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.1, cY - s * 0.18);
                    ctx.lineTo(cX - s * 0.1, cY + s * 0.18);
                    ctx.lineTo(cX + s * 0.15, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'dashed-circle': {
                    ctx.strokeStyle = '#D32F2F';
                    ctx.lineWidth = s * 0.06;
                    ctx.setLineDash([s * 0.2, s * 0.1]);
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.38, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset dash

                    ctx.fillStyle = '#D32F2F';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.1, cY - s * 0.18);
                    ctx.lineTo(cX - s * 0.1, cY + s * 0.18);
                    ctx.lineTo(cX + s * 0.15, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'simple-circle': {
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.46, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.15, cY - s * 0.22);
                    ctx.lineTo(cX - s * 0.15, cY + s * 0.22);
                    ctx.lineTo(cX + s * 0.2, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'rounded-square': {
                    ctx.fillStyle = '#212121';
                    ctx.beginPath();
                    ctx.roundRect(cX - s * 0.42, cY - s * 0.42, s * 0.84, s * 0.84, s * 0.16);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.12, cY - s * 0.2);
                    ctx.lineTo(cX - s * 0.12, cY + s * 0.2);
                    ctx.lineTo(cX + s * 0.18, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'thick-border-circle': {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.42, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.33, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.08, cY - s * 0.15);
                    ctx.lineTo(cX - s * 0.08, cY + s * 0.15);
                    ctx.lineTo(cX + s * 0.12, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'instagram': {
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.46, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.42, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.12, cY - s * 0.20);
                    ctx.lineTo(cX - s * 0.12, cY + s * 0.20);
                    ctx.lineTo(cX + s * 0.18, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'glossy-blue': {
                    const glossyGrad = ctx.createRadialGradient(cX, cY + s*0.3, s*0.1, cX, cY, s*0.6);
                    glossyGrad.addColorStop(0, "#00529B");
                    glossyGrad.addColorStop(1, "#00BFFF");

                    ctx.fillStyle = glossyGrad;
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.46, 0, Math.PI * 2);
                    ctx.fill();

                    const shineGrad = ctx.createLinearGradient(cX, cY - s*0.46, cX, cY);
                    shineGrad.addColorStop(0, "rgba(255,255,255,0.6)");
                    shineGrad.addColorStop(0.5, "rgba(255,255,255,0.1)");
                    shineGrad.addColorStop(1, "rgba(255,255,255,0.0)");
                    
                    ctx.fillStyle = shineGrad;
                    ctx.beginPath();
                    ctx.arc(cX, cY - s*0.05, s*0.42, Math.PI * 1.1, Math.PI * 1.9);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = s * 0.02;
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.13, cY - s * 0.22);
                    ctx.lineTo(cX - s * 0.13, cY + s * 0.22);
                    ctx.lineTo(cX + s * 0.2, cY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                }
            }
            
            ctx.restore();
        }
        // =================================================================
        // FIM DA CORRE√á√ÉO
        // =================================================================

        function drawDoramaElements(image) {
            ctx.save();
            
            // Calcular o multiplicador de tamanho baseado no slider
            const sizeMultiplier = doramaElementsSize / 100;
            
            // Episode Badge
            if (doramaElements.episode) {
                const x = (doramaElements.episode.x / 100) * TARGET_WIDTH;
                const y = (doramaElements.episode.y / 100) * TARGET_HEIGHT;
                const width = 80 * sizeMultiplier;
                const height = 30 * sizeMultiplier;
                const fontSize = 16 * sizeMultiplier;
                
                ctx.fillStyle = doramaBadgeColors.episode;
                ctx.beginPath();
                ctx.roundRect(x - width/2, y - height/2, width, height, height/2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('EP 1-16', x, y);
            }
            
            // Subtitle Badge
            if (doramaElements.subtitle) {
                const x = (doramaElements.subtitle.x / 100) * TARGET_WIDTH;
                const y = (doramaElements.subtitle.y / 100) * TARGET_HEIGHT;
                const width = 70 * sizeMultiplier;
                const height = 30 * sizeMultiplier;
                const fontSize = 14 * sizeMultiplier;
                
                ctx.fillStyle = doramaBadgeColors.subtitle;
                ctx.beginPath();
                ctx.roundRect(x - width/2, y - height/2, width, height, height/2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ENG SUB', x, y);
            }
            
            // HD Badge
            if (doramaElements.hd) {
                const x = (doramaElements.hd.x / 100) * TARGET_WIDTH;
                const y = (doramaElements.hd.y / 100) * TARGET_HEIGHT;
                const width = 50 * sizeMultiplier;
                const height = 30 * sizeMultiplier;
                const fontSize = 16 * sizeMultiplier;
                
                ctx.fillStyle = doramaBadgeColors.hd;
                ctx.beginPath();
                ctx.roundRect(x - width/2, y - height/2, width, height, height/2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('HD', x, y);
            }
            
            // FULL HD Badge
            if (doramaElements.fullhd) {
                const x = (doramaElements.fullhd.x / 100) * TARGET_WIDTH;
                const y = (doramaElements.fullhd.y / 100) * TARGET_HEIGHT;
                const width = 85 * sizeMultiplier;
                const height = 30 * sizeMultiplier;
                const fontSize = 14 * sizeMultiplier;
                
                ctx.fillStyle = doramaBadgeColors.fullhd;
                ctx.beginPath();
                ctx.roundRect(x - width/2, y - height/2, width, height, height/2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('FULL HD', x, y);
            }
            
            // NEW Badge
            if (doramaElements.new) {
                const x = (doramaElements.new.x / 100) * TARGET_WIDTH;
                const y = (doramaElements.new.y / 100) * TARGET_HEIGHT;
                const width = 60 * sizeMultiplier;
                const height = 30 * sizeMultiplier;
                const fontSize = 14 * sizeMultiplier;
                
                ctx.fillStyle = doramaBadgeColors.new;
                ctx.beginPath();
                ctx.roundRect(x - width/2, y - height/2, width, height, height/2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('NEW', x, y);
            }
            
            ctx.restore();
        }

        function drawLogoOverlay(image) {
            if (image.activeLogoId === null) return;

            const logo = savedLogos.find(l => l.id === image.activeLogoId);
            if (!logo || !logo.imageObj) return;

            const { x, y, width, height } = getLogoBoundingBox(image);
            ctx.drawImage(logo.imageObj, x, y, width, height);
        }

        // Fun√ß√µes auxiliares continuam...
        function getTextBoundingBox(image) {
            if (!image.headlineText) return null;
            
            let fontFamily = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
            if (image.headlineFont === 'Impact') fontFamily = "Impact, sans-serif";
            else if (image.headlineFont === 'Anton') fontFamily = "'Anton', sans-serif";
            ctx.font = `bold ${image.headlineSize}px ${fontFamily}`;
            
            const lines = wrapText(ctx, image.headlineText.toUpperCase(), TARGET_WIDTH - 80);
            const lineHeight = image.headlineSize * 1.2;
            const totalTextHeight = (lines.length * lineHeight);
            const height = totalTextHeight + 40;
            
            let width;
            if (image.headlineBackgroundStyle === 'faixa') {
                width = TARGET_WIDTH;
            } else {
                const longestLine = lines.reduce((a, b) => 
                    ctx.measureText(a).width > ctx.measureText(b).width ? a : b, "");
                width = ctx.measureText(longestLine.trim()).width + 80;
            }

            const centerX = TARGET_WIDTH * (image.headlineX / 100);
            const centerY = TARGET_HEIGHT * (image.headlineY / 100);

            return { x: centerX - width / 2, y: centerY - height / 2, width, height };
        }

        function getPlayButtonBoundingBox(image) {
            if (image.selectedPlayButton === 'none') return null;
            const size = image.playButtonSize;
            
            const centerX = TARGET_WIDTH * (image.playButtonX / 100);
            const centerY = TARGET_HEIGHT * (image.playButtonY / 100);

            return { x: centerX - size / 2, y: centerY - size / 2, width: size, height: size };
        }

        function getLogoBoundingBox(image) {
            if (image.activeLogoId === null) return null;
            const logo = savedLogos.find(l => l.id === image.activeLogoId);
            if (!logo || !logo.imageObj) return null;

            const scale = image.logoScale / 100;
            const aspect = logo.imageObj.width / logo.imageObj.height;
            let width = TARGET_WIDTH * scale;
            let height = width / aspect;
            if (height > TARGET_HEIGHT * scale) {
                height = TARGET_HEIGHT * scale;
                width = height * aspect;
            }
            
            const centerX = TARGET_WIDTH * (image.logoX / 100);
            const centerY = TARGET_HEIGHT * (image.logoY / 100);

            return { x: centerX - width / 2, y: centerY - height / 2, width, height };
        }

        function getDoramaBadgeBoundingBox(type) {
            if (!doramaElements[type]) return null;
            
            const sizeMultiplier = doramaElementsSize / 100;
            const x = (doramaElements[type].x / 100) * TARGET_WIDTH;
            const y = (doramaElements[type].y / 100) * TARGET_HEIGHT;
            
            let width, height;
            switch(type) {
                case 'episode':
                    width = 80 * sizeMultiplier;
                    height = 30 * sizeMultiplier;
                    break;
                case 'subtitle':
                    width = 70 * sizeMultiplier;
                    height = 30 * sizeMultiplier;
                    break;
                case 'hd':
                    width = 50 * sizeMultiplier;
                    height = 30 * sizeMultiplier;
                    break;
                case 'fullhd':
                    width = 85 * sizeMultiplier;
                    height = 30 * sizeMultiplier;
                    break;
                case 'new':
                    width = 60 * sizeMultiplier;
                    height = 30 * sizeMultiplier;
                    break;
                default:
                    return null;
            }
            
            return { 
                x: x - width/2, 
                y: y - height/2, 
                width, 
                height,
                centerX: x,
                centerY: y,
                type: type
            };
        }

        function handleMouseDown(e) {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage) return;

            const pos = getMousePos(outputCanvas, e);
            
            const logoBox = getLogoBoundingBox(activeImage);
            const textBox = getTextBoundingBox(activeImage);
            const playBox = getPlayButtonBoundingBox(activeImage);
            
            // Verificar badges de dorama
            let doramaBadgeHit = null;
            for (const type of ['episode', 'subtitle', 'hd', 'fullhd', 'new']) {
                const badgeBox = getDoramaBadgeBoundingBox(type);
                if (badgeBox && pos.x > badgeBox.x && pos.x < badgeBox.x + badgeBox.width && 
                    pos.y > badgeBox.y && pos.y < badgeBox.y + badgeBox.height) {
                    doramaBadgeHit = { type, box: badgeBox };
                    break;
                }
            }

            let elementCenterX, elementCenterY;

            if (doramaBadgeHit) {
                draggingElement = `dorama-${doramaBadgeHit.type}`;
                elementCenterX = doramaBadgeHit.box.centerX;
                elementCenterY = doramaBadgeHit.box.centerY;
            } else if (logoBox && pos.x > logoBox.x && pos.x < logoBox.x + logoBox.width && 
                pos.y > logoBox.y && pos.y < logoBox.y + logoBox.height) {
                draggingElement = 'logo';
                elementCenterX = logoBox.x + logoBox.width / 2;
                elementCenterY = logoBox.y + logoBox.height / 2;
            } else if (textBox && pos.x > textBox.x && pos.x < textBox.x + textBox.width && 
                       pos.y > textBox.y && pos.y < textBox.y + textBox.height) {
                draggingElement = 'text';
                elementCenterX = textBox.x + textBox.width / 2;
                elementCenterY = textBox.y + textBox.height / 2;
            } else if (playBox && pos.x > playBox.x && pos.x < playBox.x + playBox.width && 
                       pos.y > playBox.y && pos.y < playBox.y + playBox.height) {
                draggingElement = 'playButton';
                elementCenterX = playBox.x + playBox.width / 2;
                elementCenterY = playBox.y + playBox.height / 2;
            } else {
                return;
            }

            isDragging = true;
            dragOffsetX = pos.x - elementCenterX;
            dragOffsetY = pos.y - elementCenterY;
            outputCanvas.classList.add('grabbing');
        }

        function handleMouseMove(e) {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage) return;

            const pos = getMousePos(outputCanvas, e);
            
            const logoBox = getLogoBoundingBox(activeImage);
            const textBox = getTextBoundingBox(activeImage);
            const playBox = getPlayButtonBoundingBox(activeImage);
            
            // Verificar badges de dorama para cursor
            let overDoramaBadge = false;
            for (const type of ['episode', 'subtitle', 'hd', 'fullhd', 'new']) {
                const badgeBox = getDoramaBadgeBoundingBox(type);
                if (badgeBox && pos.x > badgeBox.x && pos.x < badgeBox.x + badgeBox.width && 
                    pos.y > badgeBox.y && pos.y < badgeBox.y + badgeBox.height) {
                    overDoramaBadge = true;
                    break;
                }
            }

            if (!isDragging) {
                if (overDoramaBadge ||
                    (logoBox && pos.x > logoBox.x && pos.x < logoBox.x + logoBox.width && 
                     pos.y > logoBox.y && pos.y < logoBox.y + logoBox.height) ||
                    (textBox && pos.x > textBox.x && pos.x < textBox.x + textBox.width && 
                     pos.y > textBox.y && pos.y < textBox.y + textBox.height) ||
                    (playBox && pos.x > playBox.x && pos.x < playBox.x + playBox.width && 
                     pos.y > playBox.y && pos.y < playBox.y + playBox.height)) {
                    outputCanvas.classList.add('grab');
                } else {
                    outputCanvas.classList.remove('grab');
                }
                return;
            }
            
            if (isDragging && draggingElement) {
                let newCenterX = pos.x - dragOffsetX;
                let newCenterY = pos.y - dragOffsetY;
                
                const snapThreshold = 10;

                // Snap Horizontal
                if (Math.abs(newCenterY - TARGET_HEIGHT / 2) < snapThreshold) {
                    newCenterY = TARGET_HEIGHT / 2;
                    snapStatus.horizontal = true;
                } else {
                    snapStatus.horizontal = false;
                }

                // Snap Vertical
                if (draggingElement !== 'text' || activeImage.headlineBackgroundStyle !== 'faixa') {
                    if (Math.abs(newCenterX - TARGET_WIDTH / 2) < snapThreshold) {
                        newCenterX = TARGET_WIDTH / 2;
                        snapStatus.vertical = true;
                    } else {
                        snapStatus.vertical = false;
                    }
                } else {
                    snapStatus.vertical = false;
                }
                
                // Verificar se est√° arrastando um badge de dorama
                if (draggingElement.startsWith('dorama-')) {
                    const badgeType = draggingElement.replace('dorama-', '');
                    if (doramaElements[badgeType]) {
                        doramaElements[badgeType].x = (newCenterX / TARGET_WIDTH) * 100;
                        doramaElements[badgeType].y = (newCenterY / TARGET_HEIGHT) * 100;
                    }
                } else if (draggingElement === 'logo') {
                    updateActiveImageProp('logoX', (newCenterX / TARGET_WIDTH) * 100);
                    updateActiveImageProp('logoY', (newCenterY / TARGET_HEIGHT) * 100);
                } else if (draggingElement === 'text') {
                    if (activeImage.headlineBackgroundStyle !== 'faixa') {
                        updateActiveImageProp('headlineX', (newCenterX / TARGET_WIDTH) * 100);
                    }
                    updateActiveImageProp('headlineY', (newCenterY / TARGET_HEIGHT) * 100);
                } else if (draggingElement === 'playButton') {
                    updateActiveImageProp('playButtonX', (newCenterX / TARGET_WIDTH) * 100);
                    updateActiveImageProp('playButtonY', (newCenterY / TARGET_HEIGHT) * 100);
                }
                
                redrawCanvas();
            }
        }

        function handleMouseUp(e) {
            if (isDragging) {
                isDragging = false;
                draggingElement = null;
                snapStatus = { horizontal: false, vertical: false };
                outputCanvas.classList.remove('grabbing');
                redrawCanvas();
                updateUI();
            }
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) / rect.width * TARGET_WIDTH,
                y: (evt.clientY - rect.top) / rect.height * TARGET_HEIGHT
            };
        }

        async function processImage() {
            if (isProcessing || activeImageId === null) return;
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage) return;

            isProcessing = true;
            processBtn.disabled = true;
            generateVariationsBtn.disabled = true;
            processBtn.textContent = 'Processando...';
            showNotification('Iniciando compress√£o...', 'success');
            
            redrawCanvas(activeImage);
            await new Promise(resolve => setTimeout(resolve, 50));
            processedBlob = await createCompressedBlob(activeImage);
            
            isProcessing = false;
            processBtn.disabled = false;
            generateVariationsBtn.disabled = false;
            processBtn.textContent = 'Exportar Imagem';

            if (processedBlob) {
                const finalSize = (processedBlob.size / 1024).toFixed(2);
                showNotification(`Sucesso! Tamanho final: ${finalSize}KB`, 'success');
                
                const name = exportFilenameInput.value.trim() || 
                             activeImage.name.split('.').slice(0, -1).join('.') || 
                             `criativo_${Date.now()}`;
                const format = activeImage.selectedFormat;
                
                downloadDirect(processedBlob, name, format);
            } else {
                showNotification('Falha ao comprimir a imagem.', 'error');
            }
        }

        async function createCompressedBlob(image) {
            let quality = image.quality / 100;
            const mimeType = `image/${image.selectedFormat}`;
            
            redrawCanvas(image);
            await new Promise(resolve => setTimeout(resolve, 50));

            const blob = await new Promise(resolve => 
                outputCanvas.toBlob(resolve, mimeType, quality));
            
            if (blob.size / 1024 > MAX_FILE_SIZE_KB) {
                const reducedQualityBlob = await new Promise(resolve => 
                    outputCanvas.toBlob(resolve, mimeType, 0.7));
                return reducedQualityBlob;
            }
            
            return blob;
        }

        function downloadDirect(blob, name, format) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${name}.${format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('Download iniciado!', 'success');
        }

        // Fun√ß√µes auxiliares
        function hexToRgb(hex) {
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function showNotification(message, type = 'success') {
            notification.textContent = message;
            notification.className = type;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function renderFilters() {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            filtersContainer.innerHTML = '';

            if (!activeImage) {
                filtersContainer.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9rem;">Selecione uma imagem para ver os filtros.</p>';
                return;
            }

            for (const key in FILTERS) {
                const filter = FILTERS[key];
                const itemContainer = document.createElement('div');
                itemContainer.className = 'filter-item';
                itemContainer.dataset.filter = key;

                const thumb = document.createElement('div');
                thumb.className = 'filter-thumbnail';
                thumb.style.backgroundImage = `url(${activeImage.dataURL})`;
                thumb.style.filter = filter.value;

                if (activeImage.filter === key) {
                    thumb.classList.add('active');
                }

                const nameEl = document.createElement('p');
                nameEl.className = 'filter-name';
                nameEl.textContent = filter.name;

                itemContainer.appendChild(thumb);
                itemContainer.appendChild(nameEl);
                filtersContainer.appendChild(itemContainer);
            }
        }

        function handleTemplateClick(e) {
            const deleteBtn = e.target.closest('.delete-template-btn');
            const templateBtn = e.target.closest('.control-btn');

            if (deleteBtn) {
                e.stopPropagation();
                const templateName = templateBtn.dataset.template;
                if (defaultTemplates[templateName]) {
                    deleteDefaultTemplate(templateName);
                } else {
                    deleteCustomTemplate(templateName);
                }
            } else if (templateBtn) {
                applyTemplate(templateBtn.dataset.template);
            }
        }

        function applyTemplate(templateName) {
            if (activeImageId === null) return;
            const allTemplates = {
                ...Object.keys(defaultTemplates).reduce((acc, key) => 
                    ({...acc, [key]: defaultTemplates[key].settings}), {}),
                ...customTemplates.reduce((acc, t) => 
                    ({...acc, [t.name]: t.settings}), {})
            };
            const template = allTemplates[templateName];
            if (!template) return;

            for (const prop in template) {
                updateActiveImageProp(prop, template[prop]);
            }
            redrawCanvas();
            updateUI();
            showNotification(`Template '${templateName}' aplicado!`, 'success');
        }

        function saveNewTemplate() {
            const name = newTemplateNameInput.value.trim();
            if (!name) {
                showNotification('Por favor, d√™ um nome ao template.', 'error');
                return;
            }
            if (defaultTemplates[name] || customTemplates.find(t => t.name === name)) {
                showNotification('J√° existe um template com esse nome.', 'error');
                return;
            }
            if (activeImageId === null) {
                showNotification('Selecione uma imagem para salvar o estilo.', 'error');
                return;
            }
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            const newTemplate = {
                name: name,
                settings: {
                    brightness: activeImage.brightness,
                    contrast: activeImage.contrast,
                    saturate: activeImage.saturate,
                    headlineFont: activeImage.headlineFont,
                    headlineColor: activeImage.headlineColor,
                    headlineSize: activeImage.headlineSize,
                    headlineBackgroundStyle: activeImage.headlineBackgroundStyle,
                    headlineBackgroundColor: activeImage.headlineBackgroundColor,
                    headlineBackgroundOpacity: activeImage.headlineBackgroundOpacity,
                }
            };
            customTemplates.push(newTemplate);
            saveCustomTemplates();
            renderAllTemplates();
            newTemplateNameInput.value = '';
            showNotification('Template salvo com sucesso!', 'success');
        }

        function deleteDefaultTemplate(name) {
            if (!deletedDefaultTemplates.includes(name)) {
                deletedDefaultTemplates.push(name);
                saveDeletedDefaultTemplates();
                renderAllTemplates();
                showNotification(`Template '${name}' exclu√≠do.`, 'success');
            }
        }

        function deleteCustomTemplate(name) {
            customTemplates = customTemplates.filter(t => t.name !== name);
            saveCustomTemplates();
            renderAllTemplates();
            showNotification('Template exclu√≠do!', 'success');
        }

        function resetDefaultTemplates() {
            deletedDefaultTemplates = [];
            saveDeletedDefaultTemplates();
            renderAllTemplates();
            showNotification('Templates padr√£o restaurados!', 'success');
        }

        function saveCustomTemplates() {
            localStorage.setItem('creativeProTemplates', JSON.stringify(customTemplates));
        }

        function saveDeletedDefaultTemplates() {
            localStorage.setItem('deletedDefaultTemplates', JSON.stringify(deletedDefaultTemplates));
        }

        function loadCustomTemplates() {
            const saved = localStorage.getItem('creativeProTemplates');
            if (saved) {
                customTemplates = JSON.parse(saved);
            }
        }

        function loadDeletedDefaultTemplates() {
            const saved = localStorage.getItem('deletedDefaultTemplates');
            if (saved) {
                deletedDefaultTemplates = JSON.parse(saved);
            }
        }

        function renderAllTemplates() {
            templateControls.innerHTML = '';
            for (const key in defaultTemplates) {
                if (!deletedDefaultTemplates.includes(key)) {
                    const template = defaultTemplates[key];
                    const btn = document.createElement('button');
                    btn.className = 'control-btn';
                    btn.textContent = template.name;
                    btn.dataset.template = key;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-template-btn';
                    deleteBtn.innerHTML = '&times;';
                    btn.appendChild(deleteBtn);
                    templateControls.appendChild(btn);
                }
            }
            
            customTemplatesContainer.innerHTML = '';
            customTemplates.forEach(template => {
                const btn = document.createElement('button');
                btn.className = 'control-btn';
                btn.textContent = template.name;
                btn.dataset.template = template.name;

                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'delete-template-btn';
                deleteBtn.innerHTML = '&times;';
                btn.appendChild(deleteBtn);
                customTemplatesContainer.appendChild(btn);
            });
        }

        // Logo functions
        function loadSavedLogos() {
            const saved = localStorage.getItem('creativeProLogos');
            if (saved) {
                savedLogos = JSON.parse(saved);
                savedLogos.forEach(logo => {
                    const img = new Image();
                    img.src = logo.dataURL;
                    logo.imageObj = img;
                });
                logoIdCounter = savedLogos.length > 0 ? 
                    Math.max(...savedLogos.map(l => l.id)) + 1 : 0;
            }
            renderLogoGallery();
        }

        function saveLogos() {
            const logosToSave = savedLogos.map(logo => 
                ({ id: logo.id, name: logo.name, dataURL: logo.dataURL }));
            localStorage.setItem('creativeProLogos', JSON.stringify(logosToSave));
        }

        function handleLogoUpload(files) {
            if (!files.length) return;
            const file = files[0];
            if (!file.type.startsWith('image/')) {
                showNotification('Por favor, selecione um arquivo de imagem (PNG, WebP).', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const newLogo = {
                        id: logoIdCounter++,
                        name: file.name,
                        dataURL: e.target.result,
                        imageObj: img
                    };
                    savedLogos.push(newLogo);
                    saveLogos();
                    renderLogoGallery();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function renderLogoGallery() {
            logoGalleryContainer.innerHTML = '';
            const activeImage = uploadedImages.find(img => img.id === activeImageId);

            savedLogos.forEach(logo => {
                const itemContainer = document.createElement('div');
                itemContainer.className = 'gallery-item';
                itemContainer.title = logo.name;
                itemContainer.dataset.id = logo.id;

                const thumb = document.createElement('div');
                thumb.className = 'gallery-thumbnail';
                thumb.style.backgroundImage = `url(${logo.dataURL})`;
                thumb.dataset.action = 'select';

                if (activeImage && activeImage.activeLogoId === logo.id) {
                    thumb.classList.add('active');
                }

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.dataset.action = 'delete';

                itemContainer.appendChild(deleteBtn);
                itemContainer.appendChild(thumb);
                logoGalleryContainer.appendChild(itemContainer);
            });
        }

        function handleLogoGalleryClick(e) {
            const item = e.target.closest('.gallery-item');
            if (!item || activeImageId === null) return;

            const logoId = parseInt(item.dataset.id);
            const action = e.target.dataset.action;

            if (action === 'delete') {
                e.stopPropagation();
                savedLogos = savedLogos.filter(l => l.id !== logoId);
                saveLogos();
                renderLogoGallery();
                uploadedImages.forEach(img => {
                    if (img.activeLogoId === logoId) {
                        img.activeLogoId = null;
                    }
                });
                redrawCanvas();
                updateUI();
            } else if (action === 'select') {
                updateActiveImageProp('activeLogoId', logoId);
                redrawCanvas();
                updateUI();
            }
        }

        // Batch and variations functions
        async function generateAutomaticVariations() {
            // Implementa√ß√£o simplificada por quest√£o de espa√ßo
            showNotification('Fun√ß√£o de varia√ß√µes em desenvolvimento...', 'success');
        }

        async function processBatch() {
            // Implementa√ß√£o simplificada por quest√£o de espa√ßo
            showNotification('Processamento em lote em desenvolvimento...', 'success');
        }

        // Fun√ß√£o para adicionar/remover elementos de doramas (chamada por eventos)
        function toggleDoramaElement(type) {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage) {
                showNotification('Selecione uma imagem primeiro!', 'error');
                return;
            }

            // Toggle do elemento
            if (doramaElements[type]) {
                doramaElements[type] = null;
                // Esconder o controle se nenhum elemento estiver ativo
                const hasActiveElements = Object.values(doramaElements).some(el => el !== null);
                if (!hasActiveElements) {
                    doramaElementsControls.style.display = 'none';
                }
            } else {
                // Posicionar em locais diferentes para cada badge
                let initialX = 85;
                let initialY = 15;
                
                // Ajustar posi√ß√£o inicial baseado no tipo
                switch(type) {
                    case 'episode':
                        initialX = 15;
                        initialY = 15;
                        break;
                    case 'subtitle':
                        initialX = 85;
                        initialY = 15;
                        break;
                    case 'hd':
                        initialX = 15;
                        initialY = 85;
                        break;
                    case 'fullhd':
                        initialX = 50;
                        initialY = 85;
                        break;
                    case 'new':
                        initialX = 85;
                        initialY = 85;
                        break;
                }
                
                doramaElements[type] = {
                    type: type,
                    x: initialX,
                    y: initialY
                };
                // Mostrar o controle quando houver elementos ativos
                doramaElementsControls.style.display = 'block';
                
                // Atualizar cor do picker com a cor do badge ativo
                doramaBadgeColorPicker.value = doramaBadgeColors[type];
            }
            
            // Atualizar visual dos bot√µes (vers√£o com data-dorama)
            document.querySelectorAll('button[data-dorama]').forEach(btn => {
                const t = btn.getAttribute('data-dorama');
                btn.classList.toggle('active', !!doramaElements[t]);
            });
            
            redrawCanvas();
        }

        // Fun√ß√£o global para resetar cores dos badges
        window.resetBadgeColors = function() {
            Object.keys(defaultBadgeColors).forEach(type => {
                doramaBadgeColors[type] = defaultBadgeColors[type];
            });
            // Atualizar o color picker com a cor padr√£o do primeiro badge ativo
            const activeTypes = Object.keys(doramaElements).filter(type => doramaElements[type] !== null);
            if (activeTypes.length > 0) {
                doramaBadgeColorPicker.value = doramaBadgeColors[activeTypes[0]];
            }
            requestRedraw();
            showNotification('Cores dos badges restauradas!', 'success');
        }

        // =================================================================
        // FUNCIONALIDADES DE IA
        // =================================================================
        
        // Configura√ß√£o de APIs
        let apiKeys = {
            removeBg: localStorage.getItem('removeBgApiKey') || '',
            openai: localStorage.getItem('openaiApiKey') || ''
        };
        
        // Elementos do painel IA
        const removeBgBtn = document.getElementById('remove-bg-btn');
        const removeBgStatus = document.getElementById('remove-bg-status');
        const upscaleBtn = document.getElementById('upscale-btn');
        const upscaleStatus = document.getElementById('upscale-status');
        const generateTextBtn = document.getElementById('generate-text-btn');
        const aiTextPrompt = document.getElementById('ai-text-prompt');
        const aiTextResults = document.getElementById('ai-text-results');
        const aiTextLanguage = document.getElementById('text-language');
        const analyzeBtn = document.getElementById('analyze-composition-btn');
        const compositionSuggestions = document.getElementById('composition-suggestions');
        const saveApiKeysBtn = document.getElementById('save-api-keys');
        
        // Salvar API Keys
        if (saveApiKeysBtn) {
            saveApiKeysBtn.addEventListener('click', () => {
                const removeBgKey = document.getElementById('removebg-api-key').value;
                const openaiKey = document.getElementById('openai-api-key').value;
                
                if (removeBgKey) {
                    apiKeys.removeBg = removeBgKey;
                    localStorage.setItem('removeBgApiKey', removeBgKey);
                }
                if (openaiKey) {
                    apiKeys.openai = openaiKey;
                    localStorage.setItem('openaiApiKey', openaiKey);
                }
                
                showNotification('API Keys salvas com sucesso!', 'success');
            });
        }
        
        // 1. REMOVER FUNDO COM REMOVE.BG
        if (removeBgBtn) {
            removeBgBtn.addEventListener('click', async () => {
                const activeImage = uploadedImages.find(img => img.id === activeImageId);
                if (!activeImage) {
                    showNotification('Selecione uma imagem primeiro!', 'error');
                    return;
                }
                
                if (!apiKeys.removeBg) {
                    showNotification('Configure sua API Key do Remove.bg primeiro!', 'error');
                    return;
                }
                
                removeBgStatus.textContent = '‚è≥ Processando...';
                removeBgBtn.disabled = true;
                
                try {
                    // Converter canvas para blob
                    const blob = await new Promise(resolve => 
                        outputCanvas.toBlob(resolve, 'image/png'));
                    
                    const formData = new FormData();
                    formData.append('image_file', blob, 'image.png');
                    formData.append('size', 'auto');
                    
                    const response = await fetch('https://api.remove.bg/v1.0/removebg', {
                        method: 'POST',
                        headers: {
                            'X-Api-Key': apiKeys.removeBg
                        },
                        body: formData
                    });
                    
                    if (response.ok) {
                        const arrayBuffer = await response.arrayBuffer();
                        const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                        const dataURL = `data:image/png;base64,${base64}`;
                        
                        // Criar nova imagem sem fundo
                        const newImage = {
                            ...activeImage,
                            id: imageIdCounter++,
                            name: activeImage.name.replace(/\.\w+$/, '_sem_fundo.png'),
                            dataURL: dataURL,
                            imageObj: null
                        };
                        
                        uploadedImages.push(newImage);
                        selectImage(newImage.id);
                        
                        removeBgStatus.textContent = '‚úÖ Fundo removido com sucesso!';
                        showNotification('Fundo removido! Nova imagem adicionada.', 'success');
                    } else {
                        throw new Error('Erro na API');
                    }
                } catch (error) {
                    removeBgStatus.textContent = '‚ùå Erro ao remover fundo';
                    showNotification('Erro ao remover fundo: ' + error.message, 'error');
                } finally {
                    removeBgBtn.disabled = false;
                }
            });
        }
        
        // 2. UPSCALE DE IMAGEM (Simulado com Canvas)
        if (upscaleBtn) {
            upscaleBtn.addEventListener('click', async () => {
                const activeImage = uploadedImages.find(img => img.id === activeImageId);
                if (!activeImage || !activeImage.imageObj) {
                    showNotification('Selecione uma imagem primeiro!', 'error');
                    return;
                }
                
                upscaleStatus.textContent = '‚è≥ Aumentando resolu√ß√£o...';
                upscaleBtn.disabled = true;
                
                const factor = parseInt(document.getElementById('upscale-factor').value);
                
                try {
                    // Criar canvas tempor√°rio maior
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    tempCanvas.width = TARGET_WIDTH * factor;
                    tempCanvas.height = TARGET_HEIGHT * factor;
                    
                    // Configurar qualidade m√°xima
                    tempCtx.imageSmoothingEnabled = true;
                    tempCtx.imageSmoothingQuality = 'high';
                    
                    // Desenhar imagem em alta resolu√ß√£o
                    tempCtx.drawImage(activeImage.imageObj, 0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // Converter para dataURL
                    const dataURL = tempCanvas.toDataURL('image/png', 1.0);
                    
                    // Criar nova imagem upscaled
                    const newImage = {
                        ...activeImage,
                        id: imageIdCounter++,
                        name: activeImage.name.replace(/\.\w+$/, `_${factor}x.png`),
                        dataURL: dataURL,
                        imageObj: null
                    };
                    
                    uploadedImages.push(newImage);
                    selectImage(newImage.id);
                    
                    upscaleStatus.textContent = `‚úÖ Resolu√ß√£o aumentada ${factor}x!`;
                    showNotification(`Imagem ampliada ${factor}x com sucesso!`, 'success');
                } catch (error) {
                    upscaleStatus.textContent = '‚ùå Erro no upscale';
                    showNotification('Erro ao ampliar imagem: ' + error.message, 'error');
                } finally {
                    upscaleBtn.disabled = false;
                }
            });
        }
        
        // 3. GERAR TEXTO CRIATIVO COM OPENAI
        if (generateTextBtn) {
            generateTextBtn.addEventListener('click', async () => {
                const prompt = aiTextPrompt.value.trim();
                if (!prompt) {
                    showNotification('Digite um prompt para gerar texto!', 'error');
                    return;
                }
                
                if (!apiKeys.openai) {
                    // Fallback multil√≠ngue focado em Doramas
                    const style = document.getElementById('text-style').value;
                    const lang = aiTextLanguage ? aiTextLanguage.value : 'en';
                    const fallbackTexts = {
                        en: {
                            romantic: ["LOVE BEYOND FATE","WHEN HEARTS BLOOM","MY SWEET FIRST LOVE","STARS THAT UNITE US"],
                            dramatic: ["AUTUMN TEARS","THE PRICE OF TRUTH","DANGEROUS SECRETS","THE LAST PROMISE"],
                            comedy: ["MY BOSS IS A DISASTER!","LOVE CONFUSIONS","SINGLE LIFE","LAUGHING OUT LOUD"],
                            thriller: ["SHADOWS OF THE PAST","THE INVISIBLE STALKER","SILENT REVENGE","CRIMINAL MIND"],
                            viral: ["YOU WON'T BELIEVE IT!","WHAT HE DID SHOCKED EVERYONE","BOMBSHELL REVELATION","TRY NOT TO CRY"]
                        },
                        es: {
                            romantic: ["AMOR M√ÅS ALL√Å DEL DESTINO","CUANDO FLORECE EL CORAZ√ìN","MI DULCE PRIMER AMOR","ESTRELLAS QUE NOS UNEN"],
                            dramatic: ["L√ÅGRIMAS DE OTO√ëO","EL PRECIO DE LA VERDAD","SECRETOS PELIGROSOS","LA √öLTIMA PROMESA"],
                            comedy: ["¬°MI JEFE ES UN DESASTRE!","CONFUSIONES DEL AMOR","VIDA DE SOLTERO","RIENDO A CARCAJADAS"],
                            thriller: ["SOMBRAS DEL PASADO","EL ACOSADOR INVISIBLE","VENGANZA SILENCIOSA","MENTE CRIMINAL"],
                            viral: ["¬°NO LO VAS A CREER!","LO QUE HIZO SORPRENDI√ì A TODOS","REVELACI√ìN BOMBA","IMPOSIBLE NO LLORAR"]
                        }
                    };
                    const texts = (fallbackTexts[lang] && fallbackTexts[lang][style]) || fallbackTexts.en.romantic;
                    aiTextResults.innerHTML = '<strong>Sugest√µes de texto:</strong><br>';
                    texts.forEach(text => {
                        const btn = document.createElement('button');
                        btn.className = 'text-suggestion-btn';
                        btn.textContent = text;
                        btn.style.cssText = 'display: block; width: 100%; text-align: left; padding: 0.5rem; margin: 0.25rem 0; background: var(--bg-panel); border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer;';
                        btn.onclick = () => {
                            updateActiveImageProp('headlineText', text);
                            requestRedraw();
                            showNotification('Texto aplicado!', 'success');
                        };
                        aiTextResults.appendChild(btn);
                    });
                    return;
                }

                aiTextResults.textContent = '‚è≥ Gerando textos criativos...';
                generateTextBtn.disabled = true;

                try {
                    const style = document.getElementById('text-style').value;
                    const lang = aiTextLanguage ? aiTextLanguage.value : 'en';
                    const systemByLang = {
                        en: `You are an expert at crafting short, punchy titles for K-dramas (Korean TV series). Always keep it focused on Doramas. Style: ${style}. Generate 4 short, impactful options in English only.`,
                        es: `Eres experto en crear t√≠tulos cortos e impactantes para Doramas (series coreanas). Mant√©n siempre el enfoque en Doramas. Estilo: ${style}. Genera 4 opciones cortas en espa√±ol.`
                    };
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKeys.openai}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [{
                                role: 'system',
                                content: systemByLang[lang]
                            }, {
                                role: 'user',
                                content: `${prompt}\nContext: Doramas/K-dramas only. Return plain list (no extra commentary).`
                            }],
                            temperature: 0.8,
                            max_tokens: 100
                        })
                    });
                    
                    const data = await response.json();
                    const suggestions = data.choices[0].message.content.split('\n').filter(t => t.trim());
                    
                    aiTextResults.innerHTML = '<strong>Textos gerados:</strong><br>';
                    suggestions.forEach(text => {
                        const cleanText = text.replace(/^\d+\.?\s*/, '').replace(/^[‚àí‚Äì-‚Ä¢]\s*/, '').trim();
                        const btn = document.createElement('button');
                        btn.className = 'text-suggestion-btn';
                        btn.textContent = cleanText;
                        btn.style.cssText = 'display: block; width: 100%; text-align: left; padding: 0.5rem; margin: 0.25rem 0; background: var(--bg-panel); border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer;';
                        btn.onclick = () => {
                            updateActiveImageProp('headlineText', cleanText);
                            requestRedraw();
                            showNotification('Texto aplicado!', 'success');
                        };
                        aiTextResults.appendChild(btn);
                    });
                } catch (error) {
                    aiTextResults.textContent = '‚ùå Erro ao gerar texto';
                    showNotification('Erro: ' + error.message, 'error');
                } finally {
                    generateTextBtn.disabled = false;
                }
            });
        }
        
        // 4. AN√ÅLISE DE COMPOSI√á√ÉO
        if (analyzeBtn) {
            analyzeBtn.addEventListener('click', () => {
                const activeImage = uploadedImages.find(img => img.id === activeImageId);
                if (!activeImage) {
                    showNotification('Selecione uma imagem primeiro!', 'error');
                    return;
                }
                
                compositionSuggestions.innerHTML = '<strong>üìä An√°lise da Composi√ß√£o:</strong><br><br>';
                
                // An√°lise baseada em regras
                const suggestions = [];
                
                // Verificar texto
                if (activeImage.headlineText === defaultHeadlines[0]) {
                    suggestions.push('üí° Personalize o texto para maior impacto');
                }
                
                // Verificar contraste
                if (activeImage.brightness < 80 || activeImage.brightness > 120) {
                    suggestions.push('üîÜ Ajuste o brilho para melhor legibilidade');
                }
                
                // Verificar satura√ß√£o
                if (activeImage.saturate < 80) {
                    suggestions.push('üé® Aumente a satura√ß√£o para cores mais vibrantes');
                }
                
                // Verificar elementos
                if (activeImage.selectedPlayButton === 'none') {
                    suggestions.push('‚ñ∂Ô∏è Adicione um bot√£o de play para maior engajamento');
                }
                
                // Verificar filtros
                if (activeImage.filter === 'none') {
                    suggestions.push('‚ú® Experimente filtros para criar atmosfera');
                }
                
                // Regra dos ter√ßos
                if (activeImage.headlineY < 30 || activeImage.headlineY > 70) {
                    suggestions.push('üìê Posicione o texto seguindo a regra dos ter√ßos');
                }
                
                // Badges de dorama
                const hasBadges = Object.values(doramaElements).some(el => el !== null);
                if (!hasBadges) {
                    suggestions.push('üè∑Ô∏è Adicione badges (EP, SUB, HD) para contexto');
                }
                
                if (suggestions.length === 0) {
                    suggestions.push('‚úÖ Composi√ß√£o bem equilibrada!');
                    suggestions.push('üéØ Considere testar varia√ß√µes para A/B testing');
                }
                
                suggestions.forEach(sugg => {
                    const p = document.createElement('p');
                    p.style.cssText = 'margin: 0.5rem 0; padding: 0.5rem; background: var(--bg-dark); border-radius: 4px;';
                    p.textContent = sugg;
                    compositionSuggestions.appendChild(p);
                });
                
                // Score de qualidade
                const score = Math.max(0, 100 - (suggestions.length - 1) * 15);
                const scoreEl = document.createElement('div');
                scoreEl.style.cssText = 'margin-top: 1rem; padding: 0.75rem; background: var(--accent); border-radius: 8px; text-align: center; font-weight: bold;';
                scoreEl.innerHTML = `üèÜ Score de Qualidade: ${score}/100`;
                compositionSuggestions.appendChild(scoreEl);
            });
        }

        // Inicializar aplica√ß√£o
        initializeApp();
    });
    </script>
</body>
</html>
