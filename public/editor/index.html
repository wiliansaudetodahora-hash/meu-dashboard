<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creative Pro - Editor de Criativos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #111015;
            --bg-panel: #1F1D24;
            --bg-controls: #27252C;
            --text-primary: #f0f0f5;
            --text-secondary: #a0a0b0;
            --accent: #8A63D2;
            --success: #28a745;
            --error: #dc3545;
            --border-color: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .editor-container {
            display: flex;
            height: 100vh;
        }

        /* --- Barra de Ícones Lateral --- */
        .icon-bar {
            width: 80px;
            background-color: var(--bg-panel);
            padding: 1rem 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            border-right: 1px solid var(--border-color);
        }
        .nav-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
            transition: color 0.2s ease;
            width: 100%;
            padding: 0.5rem 0;
        }
        .nav-btn svg {
            width: 28px;
            height: 28px;
        }
        .nav-btn:hover, .nav-btn.active {
            color: var(--text-primary);
            background-color: rgba(255,255,255,0.05);
        }

        /* --- Painel de Controles --- */
        .controls-panel {
            width: 380px;
            background-color: var(--bg-controls);
            padding: 1.5rem;
            overflow-y: auto;
            height: 100%;
        }
        .control-section {
            display: none;
        }
        .control-section.active {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        /* --- Área de Pré-visualização --- */
        .preview-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .top-header {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 1rem 2rem;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            gap: 1rem;
        }
        .preview-panel {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }
        .canvas-wrapper {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease-in-out;
        }
        #outputCanvas {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background-color: var(--bg-dark);
            cursor: default;
        }
        #outputCanvas.grabbing {
            cursor: grabbing;
        }
        #outputCanvas.grab {
            cursor: grab;
        }

        /* --- Componentes de UI --- */
        .card {
            background-color: var(--bg-panel);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }
        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .reset-btn {
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-secondary);
            background: none;
            border: none;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .reset-btn:hover {
            color: var(--accent);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.9rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: white;
        }
        .btn-primary {
            background-image: linear-gradient(to right, #8A63D2, #667eea);
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(138, 99, 210, 0.3);
        }
        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* --- Inputs e Controles --- */
        .form-input, textarea {
            width: 100%;
            padding: 0.75rem;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: inherit;
        }
        #upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        #upload-area.dragging {
            border-color: var(--accent);
            background-color: rgba(138, 99, 210, 0.1);
        }
        #upload-area p {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        #upload-area span {
            color: var(--accent);
            font-weight: 600;
        }
        
        #gallery-container, #logo-gallery-container, #filters-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
            max-height: 40vh;
            overflow-y: auto;
            padding: 0.5rem;
        }
        .gallery-item, .filter-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        .gallery-thumbnail, .filter-thumbnail {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            border: 3px solid transparent;
            background-size: cover;
            background-position: center;
            transition: all 0.2s ease;
        }
        #logo-gallery-container .gallery-thumbnail {
            background-size: contain;
            background-repeat: no-repeat;
        }
        .gallery-item:hover .gallery-thumbnail,
        .filter-item:hover .filter-thumbnail {
            transform: scale(1.05);
            border-color: var(--text-secondary);
        }
        .gallery-thumbnail.active,
        .filter-thumbnail.active {
            border-color: var(--accent);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(138, 99, 210, 0.4);
        }
        .gallery-name, .filter-name {
            font-size: 0.7rem;
            color: var(--text-secondary);
            width: 100%;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .delete-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: var(--error);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: scale(0.8);
            z-index: 10;
        }
        .gallery-item:hover .delete-btn {
            opacity: 1;
            transform: scale(1);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 0.75rem;
        }
        .control-btn {
            padding: 0.6rem;
            font-size: 0.85rem;
            font-weight: 500;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
            position: relative;
        }
        .control-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }
        .control-btn.active {
            border-color: var(--accent);
            background-color: rgba(138, 99, 210, 0.2);
            color: white;
            font-weight: 600;
        }
        .delete-template-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background-color: var(--error);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: scale(0.8);
        }
        .control-btn:hover .delete-template-btn {
            opacity: 1;
            transform: scale(1);
        }

        #headline-buttons-container {
            max-height: 150px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding-right: 0.5rem;
            margin-top: 1rem;
        }
        .headline-btn {
            width: 100%;
            text-align: left;
            padding: 0.6rem 0.8rem;
            font-size: 0.85rem;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .headline-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }
        .headline-btn.active {
            border-color: var(--accent);
            background-color: rgba(138, 99, 210, 0.2);
            color: white;
            font-weight: 600;
        }

        .visual-btn {
            background-color: transparent;
            border: 2px solid var(--border-color);
            padding: 0.5rem;
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        .visual-btn:hover {
            border-color: var(--text-primary);
        }
        .visual-btn.active {
            border-color: var(--accent);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(138, 99, 210, 0.4);
        }
        .visual-btn svg {
            width: 100%;
            height: 100%;
        }

        .slider-container {
            margin-top: 1rem;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        input[type="range"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            background-color: transparent;
            border: none;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch {
            border-radius: 50%;
            border: 2px solid var(--border-color);
        }
        input[type="color"]::-moz-color-swatch {
            border-radius: 50%;
            border: 2px solid var(--border-color);
        }

        #notification {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translate(-50%, 200%);
            padding: 1rem 2rem;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.4s ease-in-out;
            z-index: 1000;
        }
        #notification.show {
            transform: translate(-50%, 0);
        }
        #notification.success {
            background-color: var(--success);
        }
        #notification.error {
            background-color: var(--error);
        }
        
        .hidden {
            display: none !important;
        }
        #logo-controls {
            border-top: 1px solid var(--border-color);
            margin-top: 1.5rem;
            padding-top: 1.5rem;
        }

        .export-settings {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
        }

        /* Estilos adicionais para o painel de IA */
        .ai-section {
            margin-bottom: 1.5rem;
        }
        .ai-section h3 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }
        .ai-status {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }
        .ai-results {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        .ai-suggestions {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        .ai-options {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .api-config {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .api-hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }
        .api-hint a {
            color: var(--accent);
        }
        .btn-ai {
            background-color: var(--accent);
            color: white;
            padding: 0.6rem 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }
        .btn-ai:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(138, 99, 210, 0.3);
        }
        .btn-ai:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <!-- BARRA DE ÍCONES LATERAL -->
        <nav class="icon-bar">
            <!-- LOGO DA EMPRESA -->
            <div style="padding-bottom: 1rem; border-bottom: 1px solid var(--border-color); margin-bottom: -0.5rem;">
                <svg width="60" height="60" viewBox="0 0 60 60" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="up-logo-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#2563EB;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#06B6D4;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <g transform="translate(5, 10)">
                        <path d="M 5 5 L 5 25 C 5 30 8 33 13 33 C 18 33 21 30 21 25 L 21 5 L 17 5 L 17 25 C 17 27.5 15.5 29 13 29 C 10.5 29 9 27.5 9 25 L 9 5 Z" fill="url(#up-logo-gradient)"/>
                        <path d="M 25 5 L 25 33 L 29 33 L 29 20 L 35 20 C 39.5 20 43 16.5 43 12 C 43 7.5 39.5 5 35 5 Z M 29 9 L 35 9 C 37.2 9 39 10.3 39 12 C 39 13.7 37.2 16 35 16 L 29 16 Z" fill="url(#up-logo-gradient)"/>
                        <path d="M 35 11 L 40 16 L 35 21" fill="none" stroke="#1EE3A6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" transform="translate(-5, -4.5) scale(0.8)"/>
                    </g>
                </svg>
            </div>
            <button class="nav-btn active" data-panel="multimedia-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                <span>Multimídia</span>
            </button>
            <button class="nav-btn" data-panel="filters-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 2a7 7 0 1 0 10 10"></path></svg>
                <span>Filtros</span>
            </button>
            <button class="nav-btn" data-panel="templates-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
                <span>Templates</span>
            </button>
            <button class="nav-btn" data-panel="text-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>
                <span>Texto</span>
            </button>
            <button class="nav-btn" data-panel="elements-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path></svg>
                <span>Elementos</span>
            </button>
            <button class="nav-btn" data-panel="ai-panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6m11-11h-6m-6 0H1"></path><circle cx="12" cy="12" r="10"></circle></svg>
                <span>IA</span>
            </button>
        </nav>

        <!-- PAINEL DE CONTROLES -->
        <aside class="controls-panel">
            <!-- Seção Multimídia -->
            <div id="multimedia-panel" class="control-section active">
                <div class="card">
                    <h2 class="card-title">
                        Galeria de Imagens
                        <button class="reset-btn" id="clear-gallery-btn">Limpar Tudo</button>
                    </h2>
                    <div id="upload-area">
                        <p>Arraste e solte ou <span>clique para importar fotos</span>.</p>
                    </div>
                    <div id="gallery-container"></div>
                    <input type="file" id="file-input" accept="image/*" hidden multiple>
                </div>
            </div>

            <!-- Seção Filtros -->
            <div id="filters-panel" class="control-section">
                <div class="card">
                    <h2 class="card-title">
                        Filtros de Efeito
                        <button class="reset-btn" id="reset-filters-btn">Resetar</button>
                    </h2>
                    <div id="filters-container"></div>
                </div>
            </div>

            <!-- Seção Templates -->
            <div id="templates-panel" class="control-section">
                <div class="card">
                    <h2 class="card-title">
                        Templates de Estilo
                        <button class="reset-btn" id="reset-templates-btn">Resetar</button>
                    </h2>
                    <div class="controls-grid" id="template-controls"></div>
                    <div id="custom-templates-container" class="controls-grid" style="margin-top: 0.75rem;"></div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                        <input type="text" id="new-template-name" class="form-input" placeholder="Nome do novo template...">
                        <button id="save-template-btn" class="btn btn-secondary" style="width: auto; padding: 0 1rem;">Salvar</button>
                    </div>
                </div>
            </div>

            <!-- Seção Texto -->
            <div id="text-panel" class="control-section">
                <div class="card">
                    <h2 class="card-title">Adicionar Texto</h2>
                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: -0.8rem; margin-bottom: 1rem;">Arraste o texto na imagem para posicionar.</p>
                    <input type="text" id="custom-headline-input" class="form-input" placeholder="Ou digite seu texto aqui...">
                    <div id="headline-buttons-container"></div>
                    <h3 class="card-title" style="font-size: 0.9rem; margin-top: 1.5rem; margin-bottom: 0.75rem; border: none; padding-bottom: 0;">Fonte</h3>
                    <div class="controls-grid" id="font-family-controls">
                        <button class="control-btn" data-font="Default" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;">Padrão</button>
                        <button class="control-btn" data-font="Impact" style="font-family: Impact, sans-serif;">Impacto</button>
                        <button class="control-btn" data-font="Anton" style="font-family: 'Anton', sans-serif;">Anton</button>
                    </div>
                    <h3 class="card-title" style="font-size: 0.9rem; margin-top: 1.5rem; margin-bottom: 0.75rem; border: none; padding-bottom: 0;">Estilo do Fundo</h3>
                    <div class="controls-grid" id="text-background-controls">
                        <button class="control-btn" data-style="none">Nenhum</button>
                        <button class="control-btn" data-style="faixa">Faixa</button>
                        <button class="control-btn" data-style="capsule">Cápsula</button>
                        <button class="control-btn" data-style="vazado">Vazado</button>
                    </div>
                    <div style="display: flex; gap: 1rem; margin-top: 1.5rem; align-items: center; justify-content: space-around;">
                        <div style="text-align: center;">
                            <label style="font-size:0.8rem; color:var(--text-secondary); display: block; margin-bottom: 0.5rem;">Texto</label>
                            <input type="color" id="text-color-picker" title="Cor do Texto">
                        </div>
                        <div style="text-align: center;">
                            <label style="font-size:0.8rem; color:var(--text-secondary); display: block; margin-bottom: 0.5rem;">Fundo</label>
                            <input type="color" id="text-bg-color-picker" title="Cor do Fundo do Texto">
                        </div>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="text-bg-opacity-slider">Opacidade do Fundo</label>
                            <span id="text-bg-opacity-value">60%</span>
                        </div>
                        <input type="range" id="text-bg-opacity-slider" min="0" max="100">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="font-size-slider">Tamanho da Fonte</label>
                            <span id="font-size-value">80px</span>
                        </div>
                        <input type="range" id="font-size-slider" min="40" max="150">
                    </div>
                    <button id="remove-text-btn" class="btn btn-secondary" style="margin-top: 1.5rem;">Remover Texto</button>
                </div>
            </div>

            <!-- Seção Elementos -->
            <div id="elements-panel" class="control-section">
                <div class="card">
                    <h2 class="card-title">Preenchimento de Bordas</h2>
                    <div class="controls-grid" id="fill-mode-controls">
                        <button class="control-btn" data-mode="blur-pro">Desfoque Pro</button>
                        <button class="control-btn" data-mode="edge-extend" title="Estende as bordas da imagem de forma imperceptível">Edge Extend</button>
                        <button class="control-btn" data-mode="stretch">Esticado</button>
                        <button class="control-btn" data-mode="duotone">Duotone</button>
                        <button class="control-btn" data-mode="mosaic">Mosaico</button>
                        <button class="control-btn" data-mode="gradient">Gradiente</button>
                        <button class="control-btn" data-mode="solid">Cor Sólida</button>
                        <button class="control-btn" data-mode="smart" title="Escolhe automaticamente o melhor preenchimento">Inteligente</button>
                    </div>
                    <div id="fill-mode-options" style="margin-top: 1rem;"></div>
                </div>
                <div class="card">
                    <h2 class="card-title">Overlays de Doramas</h2>
                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: -0.8rem; margin-bottom: 1rem;">Adicione elementos típicos de streaming de doramas.</p>
                    <button id="upload-logo-btn" class="btn btn-secondary">Importar Logo/Overlay</button>
                    <input type="file" id="logo-file-input" accept="image/png, image/webp" hidden>
                    <div id="logo-gallery-container"></div>
                    <div id="logo-controls" class="hidden">
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="logo-scale-slider">Tamanho</label>
                                <span id="logo-scale-value">50%</span>
                            </div>
                            <input type="range" id="logo-scale-slider" min="10" max="150" value="50">
                        </div>
                        <button id="remove-logo-btn" class="btn btn-secondary" style="margin-top: 1.5rem;">Remover Overlay</button>
                    </div>
                    <!-- Elementos pré-definidos de doramas -->
                    <div style="margin-top: 1rem;">
                        <h4 style="font-size: 0.9rem; margin-bottom: 0.75rem;">Elementos Rápidos</h4>
                        <div class="controls-grid">
                            <button class="control-btn" data-dorama="episode">EP Badge</button>
                            <button class="control-btn" data-dorama="subtitle">SUB Badge</button>
                            <button class="control-btn" data-dorama="hd">HD Badge</button>
                            <button class="control-btn" data-dorama="fullhd">FULL HD</button>
                            <button class="control-btn" data-dorama="new">NEW Badge</button>
                        </div>
                        <div id="dorama-elements-controls" style="display: none;">
                            <div class="slider-container" style="margin-top: 1rem;">
                                <div class="slider-label">
                                    <label for="dorama-elements-size-slider">Tamanho dos Badges</label>
                                    <span id="dorama-elements-size-value">100%</span>
                                </div>
                                <input type="range" id="dorama-elements-size-slider" min="30" max="300" value="100">
                            </div>
                            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 1rem;">
                                <label style="font-size: 0.9rem;">Cor do Badge:</label>
                                <input type="color" id="dorama-badge-color" value="#FF0000" title="Cor do Badge">
                                <button class="reset-btn" id="reset-badge-colors-btn">Cores Padrão</button>
                            </div>
                            <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem;">Arraste os badges na imagem para posicionar.</p>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h2 class="card-title">
                        Ajustes de Imagem
                        <button class="reset-btn" id="reset-image-adjustments-btn">Resetar</button>
                    </h2>
                    <div class="slider-container" style="margin-top: 0;">
                        <div class="slider-label">
                            <label for="brightness-slider">Brilho</label>
                            <span id="brightness-value">100%</span>
                        </div>
                        <input type="range" id="brightness-slider" min="0" max="200" value="100">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="contrast-slider">Contraste</label>
                            <span id="contrast-value">100%</span>
                        </div>
                        <input type="range" id="contrast-slider" min="0" max="200" value="100">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="saturate-slider">Saturação</label>
                            <span id="saturate-value">100%</span>
                        </div>
                        <input type="range" id="saturate-slider" min="0" max="200" value="100">
                    </div>
                </div>
                <div class="card">
                    <h2 class="card-title">
                        Redimensionamento Manual
                        <button class="reset-btn" id="reset-transform-btn">Resetar</button>
                    </h2>
                    <div class="slider-container" style="margin-top: 0;">
                        <div class="slider-label">
                            <label for="image-scale-slider">Escala</label>
                            <span id="image-scale-value">100%</span>
                        </div>
                        <input type="range" id="image-scale-slider" min="10" max="200" value="100">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="image-x-slider">Posição X</label>
                            <span id="image-x-value">0px</span>
                        </div>
                        <input type="range" id="image-x-slider" min="-500" max="500" value="0">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="image-y-slider">Posição Y</label>
                            <span id="image-y-value">0px</span>
                        </div>
                        <input type="range" id="image-y-slider" min="-500" max="500" value="0">
                    </div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                        <button class="btn btn-secondary" id="center-image-btn" style="flex: 1;">Centralizar</button>
                        <button class="btn btn-secondary" id="fit-image-btn" style="flex: 1;">Ajustar</button>
                    </div>
                </div>
                <div class="card">
                    <h2 class="card-title">
                        Botão de Play
                        <button class="reset-btn" id="reset-play-button-btn">Resetar</button>
                    </h2>
                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: -0.8rem; margin-bottom: 1rem;">Arraste o botão na imagem para posicionar.</p>
                    <div class="controls-grid" id="play-button-controls">
                        <button class="visual-btn" data-type="none">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line><line x1="1" y1="1" x2="23" y2="23"></line></svg>
                        </button>
                        <button class="visual-btn" data-type="youtube">
                            <svg viewBox="0 0 48 48"><path fill="#FF0000" d="M42,16.4c-0.4-1.8-1.8-3.2-3.6-3.6C35.2,12,24,12,24,12s-11.2,0-14.4,0.8c-1.8,0.4-3.2,1.8-3.6,3.6C5.2,19.6,5.2,24,5.2,24s0,4.4,0.8,7.6c0.4,1.8,1.8,3.2,3.6,3.6C12.8,36,24,36,24,36s11.2,0,14.4-0.8c1.8-0.4,3.2-1.8,3.6-3.6C42.8,28.4,42.8,24,42.8,24S42.8,19.6,42,16.4z"></path><path fill="#FFFFFF" d="M20,29.5l10-5.5l-10-5.5V29.5z"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="new-tiktok">
                            <svg viewBox="0 0 48 48"><g><circle cx="27" cy="27" r="16" fill="#FF0050"></circle><circle cx="21" cy="21" r="16" fill="#00F2EA"></circle><circle cx="24" cy="24" r="14" fill="black"></circle><path fill="white" d="M21,18 l10,6 l-10,6 z"></path></g></svg>
                        </button>
                        <button class="visual-btn" data-type="gradient-circle">
                            <svg viewBox="0 0 48 48"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#8A2BE2" /><stop offset="100%" stop-color="#00BFFF" /></linearGradient></defs><circle cx="24" cy="24" r="18" stroke="url(#grad1)" stroke-width="4" fill="none"></circle><path d="M21 18 L31 24 L21 30 Z" fill="url(#grad1)"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="red-circle">
                            <svg viewBox="0 0 48 48"><circle cx="24" cy="24" r="20" fill="#FF0000"></circle><path d="M21 18 L31 24 L21 30 Z" fill="white"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="dashed-circle">
                            <svg viewBox="0 0 48 48"><circle cx="24" cy="24" r="18" stroke="#D32F2F" stroke-width="3" fill="none" stroke-dasharray="10 5" stroke-linecap="round"></circle><path d="M21 18 L31 24 L21 30 Z" fill="#D32F2F"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="simple-circle">
                            <svg viewBox="0 0 48 48"><circle cx="24" cy="24" r="22" fill="black"></circle><path d="M20 16 L32 24 L20 32 Z" fill="white"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="rounded-square">
                            <svg viewBox="0 0 48 48"><rect x="4" y="4" width="40" height="40" rx="8" fill="#212121"></rect><path d="M20 16 L32 24 L20 32 Z" fill="white"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="thick-border-circle">
                            <svg viewBox="0 0 48 48"><circle cx="24" cy="24" r="20" fill="white"></circle><circle cx="24" cy="24" r="16" fill="black"></circle><path d="M22 18 L30 24 L22 30 Z" fill="white"></path></svg>
                        </button>
                        <button class="visual-btn" data-type="instagram">
                            <svg viewBox="0 0 48 48">
                                <circle cx="24" cy="24" r="22" fill="black"></circle>
                                <circle cx="24" cy="24" r="20" fill="white"></circle>
                                <path d="M21 18 L32 24 L21 30 Z" fill="black"></path>
                            </svg>
                        </button>
                        <button class="visual-btn" data-type="glossy-blue">
                            <svg viewBox="0 0 48 48">
                                <defs>
                                    <radialGradient id="glossyBlue" cx="50%" cy="80%" r="70%" fx="50%" fy="80%">
                                        <stop offset="0%" stop-color="#00BFFF" />
                                        <stop offset="100%" stop-color="#00529B" />
                                    </radialGradient>
                                    <linearGradient id="glossyShine" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" stop-color="white" stop-opacity="0.6" />
                                        <stop offset="50%" stop-color="white" stop-opacity="0.1" />
                                        <stop offset="100%" stop-color="white" stop-opacity="0.0" />
                                    </linearGradient>
                                </defs>
                                <circle cx="24" cy="24" r="22" fill="url(#glossyBlue)" />
                                <path d="M10,8 C10,0 38,0 38,8 A22 22 0 0 1 10 8" fill="url(#glossyShine)"/>
                                <path d="M20 16 L34 24 L20 32 Z" fill="white" stroke="rgba(0,0,0,0.2)" stroke-width="1"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="play-button-size-slider">Tamanho do Botão</label>
                            <span id="play-button-size-value">120px</span>
                        </div>
                        <input type="range" id="play-button-size-slider" min="50" max="250" value="120">
                    </div>
                </div>
                <div class="card">
                    <h2 class="card-title">Exportar</h2>
                    <div class="controls-grid" id="format-controls">
                        <button class="control-btn active" data-format="jpeg">JPEG</button>
                        <button class="control-btn" data-format="png">PNG</button>
                        <button class="control-btn" data-format="webp">WebP</button>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="quality-slider">Qualidade</label>
                            <span id="quality-value">85%</span>
                        </div>
                        <input type="range" id="quality-slider" min="60" max="90" value="85">
                    </div>
                </div>
            </div>

            <!-- Seção IA -->
            <div id="ai-panel" class="control-section">
                <div class="card">
                    <h2 class="card-title">🤖 Ferramentas de IA</h2>
                    
                    <!-- Remover Fundo -->
                    <div class="ai-section">
                        <h3 class="section-subtitle">Remover Fundo</h3>
                        <button id="remove-bg-btn" class="btn btn-ai">
                            <span>🎯</span> Remover Fundo Automaticamente
                        </button>
                        <div id="remove-bg-status" class="ai-status"></div>
                    </div>

                    <!-- Upscale de Imagem -->
                    <div class="ai-section">
                        <h3 class="section-subtitle">Melhorar Qualidade</h3>
                        <div class="ai-options">
                            <select id="upscale-factor" class="form-select">
                                <option value="2">2x (Dobrar resolução)</option>
                                <option value="4">4x (Quadruplicar)</option>
                            </select>
                            <button id="upscale-btn" class="btn btn-ai">
                                <span>✨</span> Aumentar Resolução
                            </button>
                        </div>
                        <div id="upscale-status" class="ai-status"></div>
                    </div>

                    <!-- Geração de Texto -->
                    <div class="ai-section">
                        <h3 class="section-subtitle">Gerar Texto Criativo</h3>
                        <input type="text" id="ai-text-prompt" class="form-input" 
                               placeholder="Ex: título romântico para dorama coreano">
                        <div class="ai-options" style="display:flex; gap:0.5rem; align-items:center;">
                            <select id="text-style" class="form-select">
                                <option value="romantic">Romântico</option>
                                <option value="dramatic">Dramático</option>
                                <option value="comedy">Comédia</option>
                                <option value="thriller">Suspense</option>
                                <option value="viral">Viral/Clickbait</option>
                            </select>
                            <select id="text-language" class="form-select" title="Idioma do texto">
                                <option value="en">Inglês</option>
                                <option value="es">Espanhol</option>
                            </select>
                            <button id="generate-text-btn" class="btn btn-ai">
                                <span>💬</span> Gerar Texto
                            </button>
                        </div>
                        <div id="ai-text-results" class="ai-results"></div>
                    </div>

                    <!-- Sugestões de Composição -->
                    <div class="ai-section">
                        <h3 class="section-subtitle">Análise Inteligente</h3>
                        <button id="analyze-composition-btn" class="btn btn-ai">
                            <span>🎨</span> Analisar Composição
                        </button>
                        <div id="composition-suggestions" class="ai-suggestions"></div>
                    </div>

                    <!-- Configurações de API -->
                    <div class="ai-section" style="margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                        <h3 class="section-subtitle">⚙️ Configuração de APIs</h3>
                        <div class="api-config">
                            <input type="password" id="removebg-api-key" class="form-input" 
                                   placeholder="Remove.bg API Key">
                            <input type="password" id="openai-api-key" class="form-input" 
                                   placeholder="OpenAI API Key">
                            <button id="save-api-keys" class="btn btn-secondary">Salvar Chaves</button>
                        </div>
                        <p class="api-hint">
                            🔗 <a href="https://remove.bg/users/sign_up" target="_blank">Obter Remove.bg Key</a> | 
                            <a href="https://platform.openai.com/api-keys" target="_blank">Obter OpenAI Key</a>
                        </p>
                    </div>
                </div>
            </div>

        </aside>

        <!-- ÁREA DE PRÉ-VISUALIZAÇÃO -->
        <main class="preview-area">
            <div class="top-header">
                <div style="margin-right: auto; display: flex; align-items: center; gap: 1.5rem;">
                    <div id="format-selector" style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-secondary" data-size="story" style="padding: 0.6rem 1rem; width: auto;">Story (9:16)</button>
                        <button class="btn btn-secondary" data-size="square" style="padding: 0.6rem 1rem; width: auto;">Quadrado (1:1)</button>
                        <button class="btn btn-secondary" data-size="feed" style="padding: 0.6rem 1rem; width: auto;">Feed (4:5)</button>
                        <button class="btn btn-secondary" data-size="vertical" style="padding: 0.6rem 1rem; width: auto;">Vertical (2:3)</button>
                    </div>
                </div>
                <button id="batch-process-btn" class="btn btn-secondary" style="margin-right: 0.5rem;">Processar Lote</button>
                <input type="text" id="export-filename-input" class="form-input" placeholder="Nome do arquivo..." style="width: 200px;">
                <button id="process-btn" class="btn btn-secondary">Exportar Imagem</button>
                <button id="generate-variations-btn" class="btn btn-primary">Gerar Variações</button>
                <input type="number" id="variations-count" class="form-input" value="10" min="1" max="50" style="width: 70px; text-align: center; padding: 0.6rem 0.5rem;">
            </div>
            <div class="preview-panel">
                <div class="canvas-wrapper">
                    <canvas id="outputCanvas"></canvas>
                </div>
            </div>
        </main>
    </div>

    <!-- Elemento de Notificação -->
    <div id="notification"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Polyfill para roundRect ---
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, radii) {
                // ...
                if (!Array.isArray(radii)) radii = [radii, radii, radii, radii];
                this.beginPath();
                this.moveTo(x + radii[0], y);
                this.lineTo(x + w - radii[1], y);
                this.quadraticCurveTo(x + w, y, x + w, y + radii[1]);
                this.lineTo(x + w, y + h - radii[2]);
                this.quadraticCurveTo(x + w, y + h, x + w - radii[2], y + h);
                this.lineTo(x + radii[3], y + h);
                this.quadraticCurveTo(x, y + h, x, y + h - radii[3]);
                this.lineTo(x, y + radii[0]);
                this.quadraticCurveTo(x, y, x + radii[0], y);
                this.closePath();
            };
        }

        // --- Variáveis Globais ---
        let processedBlob = null;
        let uploadedImages = [];
        let activeImageId = null;
        let isProcessing = false;
        let headlineSourceList = [];
        let customTemplates = [];
        let deletedDefaultTemplates = [];
        let imageIdCounter = 0;
        let savedLogos = [];
        let logoIdCounter = 0;
        let doramaElements = {
            episode: null,
            subtitle: null,
            hd: null,
            fullhd: null,
            new: null
        };
        let doramaElementsSize = 100; // Tamanho padrão em porcentagem
        let doramaBadgeColors = {
            episode: '#FF0000',
            subtitle: '#0099CC',
            hd: '#4CAF50',
            fullhd: '#9C27B0',
            new: '#FFA500'
        };
        const defaultBadgeColors = {
            episode: '#FF0000',
            subtitle: '#0099CC',
            hd: '#4CAF50',
            fullhd: '#9C27B0',
            new: '#FFA500'
        };

        // Variáveis de estado para arrastar elementos
        let isDragging = false;
        let draggingElement = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let snapStatus = { horizontal: false, vertical: false };

        let TARGET_WIDTH = 1080, TARGET_HEIGHT = 1920;
        // Debounce para redraw e operações pesadas
        let _redrawTimer = null;
        function requestRedraw() {
            if (_redrawTimer) cancelAnimationFrame(_redrawTimer);
            _redrawTimer = requestAnimationFrame(() => {
                redrawCanvas();
            });
        }
        const MAX_FILE_SIZE_KB = 500;

        // --- Seletores DOM ---
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = outputCanvas.getContext('2d');
        const qualitySlider = document.getElementById('quality-slider');
        const qualityValue = document.getElementById('quality-value');
        const processBtn = document.getElementById('process-btn');
        const notification = document.getElementById('notification');
        const headlineButtonsContainer = document.getElementById('headline-buttons-container');
        const generateVariationsBtn = document.getElementById('generate-variations-btn');
        const textColorPicker = document.getElementById('text-color-picker');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValue = document.getElementById('font-size-value');
        const removeTextBtn = document.getElementById('remove-text-btn');
        const textBgColorPicker = document.getElementById('text-bg-color-picker');
        const textBgOpacitySlider = document.getElementById('text-bg-opacity-slider');
        const textBgOpacityValue = document.getElementById('text-bg-opacity-value');
        const galleryContainer = document.getElementById('gallery-container');
        const playButtonSizeSlider = document.getElementById('play-button-size-slider');
        const playButtonSizeValue = document.getElementById('play-button-size-value');
        const brightnessSlider = document.getElementById('brightness-slider');
        const brightnessValue = document.getElementById('brightness-value');
        const contrastSlider = document.getElementById('contrast-slider');
        const contrastValue = document.getElementById('contrast-value');
        const saturateSlider = document.getElementById('saturate-slider');
        const saturateValue = document.getElementById('saturate-value');
        const resetImageAdjustmentsBtn = document.getElementById('reset-image-adjustments-btn');
        const resetPlayButtonBtn = document.getElementById('reset-play-button-btn');
        const customHeadlineInput = document.getElementById('custom-headline-input');
        const clearGalleryBtn = document.getElementById('clear-gallery-btn');
        const newTemplateNameInput = document.getElementById('new-template-name');
        const saveTemplateBtn = document.getElementById('save-template-btn');
        const customTemplatesContainer = document.getElementById('custom-templates-container');
        const templateControls = document.getElementById('template-controls');
        const resetTemplatesBtn = document.getElementById('reset-templates-btn');
        const variationsCountInput = document.getElementById('variations-count');
        const fillModeOptionsContainer = document.getElementById('fill-mode-options');
        const exportFilenameInput = document.getElementById('export-filename-input');
        const batchProcessBtn = document.getElementById('batch-process-btn');
        const uploadLogoBtn = document.getElementById('upload-logo-btn');
        const logoFileInput = document.getElementById('logo-file-input');
        const logoGalleryContainer = document.getElementById('logo-gallery-container');
        const logoControls = document.getElementById('logo-controls');
        const logoScaleSlider = document.getElementById('logo-scale-slider');
        const logoScaleValue = document.getElementById('logo-scale-value');
        const removeLogoBtn = document.getElementById('remove-logo-btn');
        const formatSelector = document.getElementById('format-selector');
        const canvasWrapper = document.querySelector('.canvas-wrapper');
        const filtersContainer = document.getElementById('filters-container');
        const resetFiltersBtn = document.getElementById('reset-filters-btn');
        const doramaElementsSizeSlider = document.getElementById('dorama-elements-size-slider');
        const doramaElementsSizeValue = document.getElementById('dorama-elements-size-value');
        const doramaElementsControls = document.getElementById('dorama-elements-controls');
        const doramaBadgeColorPicker = document.getElementById('dorama-badge-color');

        // --- Constantes ---
        const defaultHeadlines = [
            "WATCH FREE NOW", "STREAM NOW FREE", "FREE EPISODES HERE", "FINAL EPISODE FREE",
            "WATCH FULL DRAMA", "ALL EPISODES FREE", "TAP TO WATCH", "NEW KOREAN DRAMA",
            "WATCH BEFORE DELETED", "EXCLUSIVE DRAMA", "TRENDING NOW", "MOST WATCHED DRAMA",
            "SHOCKING ENDING", "ROMANTIC DRAMA", "MUST WATCH TODAY", "VIRAL KOREAN SERIES",
            "ENGLISH SUBTITLES", "WATCH WITH SUBS", "HD QUALITY FREE", "BINGE WATCH NOW",
            "WATCH NOW", "ALL EPISODES", "FOR FREE", "DIVORCED AT THE WEDDING DAY",
            "VER GRATIS AHORA", "EPISODIOS GRATIS", "DORAMA COMPLETO", "ÚLTIMO CAPÍTULO",
            "VER AHORA GRATIS", "TODOS LOS EPISODIOS", "TOCA PARA VER", "NUEVO DORAMA",
            "VER ANTES QUE BORREN", "DORAMA EXCLUSIVO", "LO MÁS VISTO", "DRAMA COREANO",
            "FINAL IMPACTANTE", "DORAMA ROMÁNTICO", "MÍRALO HOY", "SERIE VIRAL",
            "SUBTÍTULOS ESPAÑOL", "CON SUBTÍTULOS", "CALIDAD HD GRATIS", "MARATÓN GRATIS",
            "ROMANCE DRAMA FREE", "ACTION KDRAMA", "MEDICAL DRAMA", "SCHOOL ROMANCE",
            "DORAMA DE AMOR", "ACCIÓN COREANA", "DRAMA MÉDICO", "ROMANCE ESCOLAR"
        ];

        const defaultTemplates = {
            kdrama_romantic: { 
                name: 'K-Drama Romântico', 
                settings: { 
                    brightness: 105, contrast: 110, saturate: 115, 
                    headlineFont: 'Default', headlineBackgroundStyle: 'capsule', 
                    headlineBackgroundColor: '#FF1493', headlineBackgroundOpacity: 0.85, 
                    headlineColor: '#FFFFFF' 
                }
            },
            kdrama_suspense: { 
                name: 'K-Drama Suspense', 
                settings: { 
                    brightness: 90, contrast: 120, saturate: 85, 
                    headlineFont: 'Impact', headlineBackgroundStyle: 'faixa', 
                    headlineBackgroundColor: '#000000', headlineBackgroundOpacity: 0.9, 
                    headlineColor: '#FFFFFF' 
                }
            },
            kdrama_trending: { 
                name: 'K-Drama Viral', 
                settings: { 
                    brightness: 110, contrast: 115, saturate: 125, 
                    headlineFont: 'Anton', headlineBackgroundStyle: 'faixa', 
                    headlineBackgroundColor: '#FF0000', headlineBackgroundOpacity: 1, 
                    headlineColor: '#FFFFFF' 
                }
            },
            dorama_espanol: { 
                name: 'Dorama Español', 
                settings: { 
                    brightness: 105, contrast: 110, saturate: 120, 
                    headlineFont: 'Impact', headlineBackgroundStyle: 'capsule', 
                    headlineBackgroundColor: '#FFA500', headlineBackgroundOpacity: 0.9, 
                    headlineColor: '#000000' 
                }
            },
            netflix_style: { 
                name: 'Estilo Netflix', 
                settings: { 
                    brightness: 95, contrast: 115, saturate: 100, 
                    headlineFont: 'Default', headlineBackgroundStyle: 'faixa', 
                    headlineBackgroundColor: '#E50914', headlineBackgroundOpacity: 0.95, 
                    headlineColor: '#FFFFFF' 
                }
            },
            viki_style: { 
                name: 'Estilo Viki', 
                settings: { 
                    brightness: 100, contrast: 105, saturate: 110, 
                    headlineFont: 'Default', headlineBackgroundStyle: 'vazado', 
                    headlineBackgroundColor: '#00D4FF', headlineBackgroundOpacity: 0.8, 
                    headlineColor: '#FFFFFF' 
                }
            },
            watch_now_style: {
                name: 'Watch Now Premium',
                settings: {
                    brightness: 105, contrast: 115, saturate: 110,
                    headlineFont: 'Anton', headlineBackgroundStyle: 'faixa',
                    headlineBackgroundColor: '#FFD700', headlineBackgroundOpacity: 0.9,
                    headlineColor: '#000000',
                    filter: 'dramatic'
                }
            }
        };

        const FILTERS = {
            'none': { name: 'Nenhum', value: '' },
            'kdrama': { name: 'K-Drama', value: 'contrast(1.1) saturate(1.3) brightness(1.05) sepia(0.1)' },
            'romantic': { name: 'Romântico', value: 'contrast(1.05) saturate(1.4) brightness(1.1) hue-rotate(-5deg)' },
            'dramatic': { name: 'Dramático', value: 'contrast(1.4) brightness(0.85) saturate(1.2)' },
            'vintage': { name: 'Vintage', value: 'sepia(0.3) contrast(1.2) brightness(0.95) saturate(1.2)' },
            'cinematic': { name: 'Cinemático', value: 'contrast(1.3) saturate(1.4) brightness(0.8)' },
            'emotional': { name: 'Emocional', value: 'contrast(1.2) saturate(0.8) brightness(0.95) sepia(0.15)' },
            'vibrant': { name: 'Vibrante', value: 'saturate(1.8) contrast(1.1) brightness(1.05)' },
            'soft': { name: 'Suave', value: 'contrast(0.95) saturate(1.2) brightness(1.1) blur(0.3px)' }
        };

        // --- Inicialização ---
        function initializeApp() {
            setCanvasSize('story');
            initializeHeadlineButtons();
            renderFilters();
            loadCustomTemplates();
            loadDeletedDefaultTemplates();
            renderAllTemplates();
            loadSavedLogos();
        }

        // --- Event Listeners ---
        galleryContainer.addEventListener('click', (e) => {
            const item = e.target.closest('.gallery-item');
            if (!item) return;

            const id = parseInt(item.dataset.id);
            const action = e.target.dataset.action;

            if (action === 'delete') {
                e.stopPropagation();
                deleteImage(id);
            } else { // Clicar em qualquer lugar do item seleciona
                selectImage(id);
            }
        });

        uploadArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files));

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragging'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragging'), false);
        });
        uploadArea.addEventListener('drop', handleDrop, false);

        document.getElementById('fill-mode-controls').addEventListener('click', (e) => handleControlClick(e, 'data-mode', (newMode) => {
            updateActiveImageProp('fillMode', newMode);
            redrawCanvas();
            updateUI();
        }));

        document.getElementById('play-button-controls').addEventListener('click', (e) => handleControlClick(e, 'data-type', (newType) => {
            updateActiveImageProp('selectedPlayButton', newType);
            redrawCanvas();
            updateUI();
        }, 'visual-btn'));

        document.getElementById('text-background-controls').addEventListener('click', (e) => handleControlClick(e, 'data-style', (newStyle) => {
            updateActiveImageProp('headlineBackgroundStyle', newStyle);
            redrawCanvas();
            updateUI();
        }));

        document.getElementById('format-controls').addEventListener('click', (e) => handleControlClick(e, 'data-format', (newFormat) => {
            updateActiveImageProp('selectedFormat', newFormat);
            updateUI();
        }));

        document.getElementById('font-family-controls').addEventListener('click', (e) => handleControlClick(e, 'data-font', (newFont) => {
            updateActiveImageProp('headlineFont', newFont);
            redrawCanvas();
            updateUI();
        }));

        templateControls.addEventListener('click', (e) => handleTemplateClick(e));
        customTemplatesContainer.addEventListener('click', (e) => handleTemplateClick(e));

        headlineButtonsContainer.addEventListener('click', (e) => handleControlClick(e, 'data-text', (newText) => {
            updateActiveImageProp('headlineText', newText);
            customHeadlineInput.value = '';
            redrawCanvas();
            updateUI();
        }, 'headline-btn'));

        customHeadlineInput.addEventListener('input', (e) => {
            updateActiveImageProp('headlineText', e.target.value);
            redrawCanvas();
            document.querySelectorAll('#headline-buttons-container .headline-btn').forEach(btn => btn.classList.remove('active'));
        });

        removeTextBtn.addEventListener('click', () => {
            updateActiveImageProp('headlineText', '');
            customHeadlineInput.value = '';
            redrawCanvas();
            updateUI();
        });

        textColorPicker.addEventListener('input', (e) => {
            updateActiveImageProp('headlineColor', e.target.value);
            redrawCanvas();
        });

        fontSizeSlider.addEventListener('input', (e) => {
            updateActiveImageProp('headlineSize', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });

        qualitySlider.addEventListener('input', (e) => {
            updateActiveImageProp('quality', parseInt(e.target.value));
            updateUI();
        });

        textBgColorPicker.addEventListener('input', (e) => {
            updateActiveImageProp('headlineBackgroundColor', e.target.value);
            redrawCanvas();
        });

        textBgOpacitySlider.addEventListener('input', (e) => {
            const opacityValue = parseInt(e.target.value);
            updateActiveImageProp('headlineBackgroundOpacity', opacityValue / 100);
            redrawCanvas();
            updateUI();
        });

        playButtonSizeSlider.addEventListener('input', (e) => {
            updateActiveImageProp('playButtonSize', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });

        brightnessSlider.addEventListener('input', (e) => {
            updateActiveImageProp('brightness', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });

        contrastSlider.addEventListener('input', (e) => {
            updateActiveImageProp('contrast', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });

        saturateSlider.addEventListener('input', (e) => {
            updateActiveImageProp('saturate', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });

        resetImageAdjustmentsBtn.addEventListener('click', () => {
            updateActiveImageProp('brightness', 100);
            updateActiveImageProp('contrast', 100);
            updateActiveImageProp('saturate', 100);
            redrawCanvas();
            updateUI();
        });

        resetPlayButtonBtn.addEventListener('click', () => {
            updateActiveImageProp('playButtonSize', 120);
            redrawCanvas();
            updateUI();
        });

        const imageScaleSlider = document.getElementById('image-scale-slider');
        const imageXSlider = document.getElementById('image-x-slider');
        const imageYSlider = document.getElementById('image-y-slider');
        const resetTransformBtn = document.getElementById('reset-transform-btn');
        const centerImageBtn = document.getElementById('center-image-btn');
        const fitImageBtn = document.getElementById('fit-image-btn');

        if (imageScaleSlider) {
            imageScaleSlider.addEventListener('input', (e) => {
                updateActiveImageProp('imageScale', parseInt(e.target.value));
                redrawCanvas();
                updateUI();
            });
        }

        if (imageXSlider) {
            imageXSlider.addEventListener('input', (e) => {
                updateActiveImageProp('imageX', parseInt(e.target.value));
                redrawCanvas();
                updateUI();
            });
        }

        if (imageYSlider) {
            imageYSlider.addEventListener('input', (e) => {
                updateActiveImageProp('imageY', parseInt(e.target.value));
                redrawCanvas();
                updateUI();
            });
        }

        if (resetTransformBtn) {
            resetTransformBtn.addEventListener('click', () => {
                updateActiveImageProp('imageScale', 100);
                updateActiveImageProp('imageX', 0);
                updateActiveImageProp('imageY', 0);
                redrawCanvas();
                updateUI();
            });
        }

        if (centerImageBtn) {
            centerImageBtn.addEventListener('click', () => {
                updateActiveImageProp('imageX', 0);
                updateActiveImageProp('imageY', 0);
                redrawCanvas();
                updateUI();
            });
        }

        if (fitImageBtn) {
            fitImageBtn.addEventListener('click', () => {
                fitImageToCanvas();
            });
        }
        
        // Função para ajustar imagem ao canvas
        function fitImageToCanvas() {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage || !activeImage.imageObj) return;
            
            const canvasAspectRatio = TARGET_WIDTH / TARGET_HEIGHT;
            const imgAspectRatio = activeImage.imageObj.width / activeImage.imageObj.height;
            
            let scale;
            if (canvasAspectRatio > imgAspectRatio) {
                // Imagem é mais alta proporcionalmente
                scale = (TARGET_HEIGHT / activeImage.imageObj.height) * 100;
            } else {
                // Imagem é mais larga proporcionalmente
                scale = (TARGET_WIDTH / activeImage.imageObj.width) * 100;
            }
            
            updateActiveImageProp('imageScale', Math.min(scale, 200));
            updateActiveImageProp('imageX', 0);
            updateActiveImageProp('imageY', 0);
            redrawCanvas();
            updateUI();
        }

        clearGalleryBtn.addEventListener('click', clearGallery);
        saveTemplateBtn.addEventListener('click', saveNewTemplate);
        resetTemplatesBtn.addEventListener('click', resetDefaultTemplates);

        processBtn.addEventListener('click', processImage);
        generateVariationsBtn.addEventListener('click', generateAutomaticVariations);
        batchProcessBtn.addEventListener('click', processBatch);

        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                document.querySelectorAll('.control-section').forEach(s => s.classList.remove('active'));
                const panel = document.getElementById(btn.dataset.panel);
                if (panel) {
                    panel.classList.add('active');
                }
            });
        });

        uploadLogoBtn.addEventListener('click', () => logoFileInput.click());
        logoFileInput.addEventListener('change', (e) => handleLogoUpload(e.target.files));
        logoGalleryContainer.addEventListener('click', handleLogoGalleryClick);
        logoScaleSlider.addEventListener('input', (e) => {
            updateActiveImageProp('logoScale', parseInt(e.target.value));
            redrawCanvas();
            updateUI();
        });
        removeLogoBtn.addEventListener('click', () => {
            updateActiveImageProp('activeLogoId', null);
            redrawCanvas();
            updateUI();
        });

        outputCanvas.addEventListener('mousedown', handleMouseDown);
        outputCanvas.addEventListener('mousemove', handleMouseMove);
        outputCanvas.addEventListener('mouseup', handleMouseUp);
        outputCanvas.addEventListener('mouseleave', handleMouseUp);

        formatSelector.addEventListener('click', (e) => {
            const button = e.target.closest('button');
            if (button && button.dataset.size) {
                setCanvasSize(button.dataset.size);
            }
        });

        filtersContainer.addEventListener('click', (e) => {
            const item = e.target.closest('.filter-item');
            if (item && item.dataset.filter) {
                const filterKey = item.dataset.filter;
                updateActiveImageProp('filter', filterKey);
                redrawCanvas();
                renderFilters();
            }
        });

        resetFiltersBtn.addEventListener('click', () => {
            updateActiveImageProp('filter', 'none');
            redrawCanvas();
            renderFilters();
        });

        // Event listener para o slider de tamanho dos elementos de dorama
        doramaElementsSizeSlider.addEventListener('input', (e) => {
            doramaElementsSize = parseInt(e.target.value);
            doramaElementsSizeValue.textContent = `${doramaElementsSize}%`;
            redrawCanvas();
        });

        // Event listener para o seletor de cor dos badges
        doramaBadgeColorPicker.addEventListener('input', (e) => {
            const activeTypes = Object.keys(doramaElements).filter(type => doramaElements[type] !== null);
            activeTypes.forEach(type => {
                doramaBadgeColors[type] = e.target.value;
            });
            redrawCanvas();
        });

        // Botão "Cores Padrão" dos badges
        const resetBadgeColorsBtn = document.getElementById('reset-badge-colors-btn');
        if (resetBadgeColorsBtn) {
            resetBadgeColorsBtn.addEventListener('click', () => {
                const defaultColor = doramaBadgeColorPicker && doramaBadgeColorPicker.defaultValue ? doramaBadgeColorPicker.defaultValue : '#FF0000';
                const activeTypes = Object.keys(doramaElements).filter(type => doramaElements[type] !== null);
                activeTypes.forEach(type => {
                    doramaBadgeColors[type] = defaultColor;
                });
                if (doramaBadgeColorPicker) doramaBadgeColorPicker.value = defaultColor;
                redrawCanvas();
            });
        }

        // Atalhos de teclado
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        if (!isProcessing && activeImageId !== null) {
                            processImage();
                        }
                        break;
                    case 'g':
                        e.preventDefault();
                        if (!isProcessing && activeImageId !== null) {
                            generateAutomaticVariations();
                        }
                        break;
                    case 'b':
                        e.preventDefault();
                        if (!isProcessing && uploadedImages.length > 0) {
                            processBatch();
                        }
                        break;
                    case 'Delete':
                        if (activeImageId !== null) {
                            deleteImage(activeImageId);
                        }
                        break;
                }
            }
            
            // Navegação entre imagens com setas
            if (activeImageId !== null && !e.ctrlKey && !e.metaKey) {
                const currentIndex = uploadedImages.findIndex(img => img.id === activeImageId);
                if (e.key === 'ArrowLeft' && currentIndex > 0) {
                    selectImage(uploadedImages[currentIndex - 1].id);
                } else if (e.key === 'ArrowRight' && currentIndex < uploadedImages.length - 1) {
                    selectImage(uploadedImages[currentIndex + 1].id);
                }
            }
        });

        // --- Funções Principais ---
        function setCanvasSize(size) {
            if (size === 'square') {
                TARGET_WIDTH = 1024;
                TARGET_HEIGHT = 1024;
                canvasWrapper.style.aspectRatio = '1 / 1';
                canvasWrapper.style.maxWidth = '600px';
            } else if (size === 'feed') {
                TARGET_WIDTH = 1080;
                TARGET_HEIGHT = 1350;
                canvasWrapper.style.aspectRatio = '4 / 5';
                canvasWrapper.style.maxWidth = '480px';
            } else if (size === 'vertical') {
                TARGET_WIDTH = 1024;
                TARGET_HEIGHT = 1536;
                canvasWrapper.style.aspectRatio = '2 / 3';
                canvasWrapper.style.maxWidth = '400px';
            } else { // Default to 'story'
                TARGET_WIDTH = 1080;
                TARGET_HEIGHT = 1920;
                canvasWrapper.style.aspectRatio = '9 / 16';
                canvasWrapper.style.maxWidth = '405px';
            }

            outputCanvas.width = TARGET_WIDTH;
            outputCanvas.height = TARGET_HEIGHT;

            formatSelector.querySelectorAll('button').forEach(btn => {
                const isSelected = btn.dataset.size === size;
                btn.classList.toggle('btn-primary', isSelected);
                btn.classList.toggle('btn-secondary', !isSelected);
            });
            
            requestRedraw();
        }

        // Delegação de eventos para botões do painel de elementos (corrige onclicks que quebraram)
        const elementsPanel = document.getElementById('elements-panel');
        if (elementsPanel) {
            elementsPanel.addEventListener('click', (e) => {
                const btn = e.target.closest('button[data-dorama]');
                if (!btn) return;
                const type = btn.getAttribute('data-dorama');
                toggleDoramaElement(type);
                // Atualiza estado visual
                btn.classList.toggle('active', doramaElements[type] !== null);
            });
        }

        function initializeHeadlineButtons() {
            headlineSourceList = defaultHeadlines;
            headlineButtonsContainer.innerHTML = '';
            headlineSourceList.forEach((text) => {
                const button = document.createElement('button');
                button.className = 'headline-btn';
                button.textContent = text;
                button.dataset.text = text;
                headlineButtonsContainer.appendChild(button);
            });
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            preventDefaults(e);
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFileSelect(files);
        }

        function handleFileSelect(files) {
            if (files.length === 0) return;
            
            let filesToLoad = Array.from(files).filter(file => file.type.startsWith('image/')).length;
            if (filesToLoad === 0) return;
            
            for(const file of files) {
                if (!file.type.startsWith('image/')) {
                    showNotification(`'${file.name}' não é uma imagem.`, 'error');
                    continue;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const newImage = {
                        id: imageIdCounter++,
                        name: file.name,
                        dataURL: e.target.result,
                        imageObj: null,
                        imageColors: null,
                        composition: null,
                        filter: 'none',
                        fillMode: 'blur-pro',
                        blurAmount: 40,
                        solidFillColor: '#000000',
                        brightness: 100,
                        contrast: 100,
                        saturate: 100,
                        headlineText: defaultHeadlines[0],
                        headlineFont: 'Default',
                        headlineColor: '#FFFFFF',
                        headlineSize: 80,
                        headlineBackgroundStyle: 'faixa',
                        headlineBackgroundColor: '#000000',
                        headlineBackgroundOpacity: 0.6,
                        headlineX: 50,
                        headlineY: 85,
                        selectedPlayButton: 'none',
                        playButtonSize: 120,
                        playButtonX: 50,
                        playButtonY: 50,
                        imageScale: 100,
                        imageX: 0,
                        imageY: 0,
                        selectedFormat: 'jpeg',
                        quality: 85
                    };
                    
                    uploadedImages.push(newImage);
                    
                    filesToLoad--;
                    if (filesToLoad === 0) {
                        if (activeImageId === null && uploadedImages.length > 0) {
                            // Primeira carga: selecione a última imagem adicionada
                            selectImage(uploadedImages[uploadedImages.length - 1].id);
                        } else {
                            // Já havia uma imagem ativa: apenas atualize a galeria
                            renderGallery();
                        }
                    }
                };
                reader.readAsDataURL(file);
            }
        }

        function renderGallery() {
            galleryContainer.innerHTML = '';
            uploadedImages.forEach(image => {
                const itemContainer = document.createElement('div');
                itemContainer.className = 'gallery-item';
                itemContainer.title = image.name;
                itemContainer.dataset.id = image.id;

                const thumb = document.createElement('div');
                thumb.className = 'gallery-thumbnail';
                thumb.style.backgroundImage = `url(${image.dataURL})`;
                
                if (image.id === activeImageId) {
                    thumb.classList.add('active');
                }

                const nameEl = document.createElement('p');
                nameEl.className = 'gallery-name';
                nameEl.textContent = image.name;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.dataset.action = 'delete';

                itemContainer.appendChild(deleteBtn);
                itemContainer.appendChild(thumb);
                itemContainer.appendChild(nameEl);
                galleryContainer.appendChild(itemContainer);
            });
        }
        
        // Análise básica de cores (fallback leve para evitar travar carregamento)
        async function analyzeImageColors(img, quick = true) {
            try {
                const sampleW = 120;
                const aspect = img.width / img.height;
                const w = sampleW;
                const h = Math.max(1, Math.round(sampleW / (aspect || 1)));
                const canv = document.createElement('canvas');
                const cctx = canv.getContext('2d');
                canv.width = w;
                canv.height = h;
                cctx.drawImage(img, 0, 0, w, h);
                const data = cctx.getImageData(0, 0, w, h).data;

                let rSum = 0, gSum = 0, bSum = 0, n = 0;
                let rTop = 0, gTop = 0, bTop = 0, nTop = 0;
                let rBot = 0, gBot = 0, bBot = 0, nBot = 0;
                const quantize = (v) => Math.min(255, Math.max(0, Math.round(v / 16) * 16));
                const paletteMap = new Map();

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const idx = (y * w + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        rSum += r; gSum += g; bSum += b; n++;
                        if (y < h / 3) { rTop += r; gTop += g; bTop += b; nTop++; }
                        if (y >= (2 * h) / 3) { rBot += r; gBot += g; bBot += b; nBot++; }
                        const qr = quantize(r), qg = quantize(g), qb = quantize(b);
                        const key = `${qr},${qg},${qb}`;
                        paletteMap.set(key, (paletteMap.get(key) || 0) + 1);
                    }
                }

                const avg = [Math.round(rSum / n), Math.round(gSum / n), Math.round(bSum / n)];
                const top = nTop ? [Math.round(rTop / nTop), Math.round(gTop / nTop), Math.round(bTop / nTop)] : avg;
                const bottom = nBot ? [Math.round(rBot / nBot), Math.round(gBot / nBot), Math.round(bBot / nBot)] : avg;

                // Top N cores mais frequentes
                const palette = Array.from(paletteMap.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 8)
                    .map(([k]) => k.split(',').map(v => parseInt(v, 10)));

                return {
                    dominant: avg,
                    top,
                    bottom,
                    palette
                };
            } catch (err) {
                // Fallback defensivo
                return {
                    dominant: [40, 40, 40],
                    top: [40, 40, 40],
                    bottom: [40, 40, 40],
                    palette: [[40, 40, 40]]
                };
            }
        }

        // Análise básica de composição (fallback leve)
        async function analyzeImageComposition(img) {
            // Heurística simples: usa proporção da imagem como "aspectRatio do sujeito"
            // e assume área central ocupando ~45%.
            const aspect = img.width && img.height ? (img.width / img.height) : 1;
            return {
                subjectBox: {
                    areaRatio: 0.45,
                    aspectRatio: aspect
                }
            };
        }

        async function selectImage(id) {
            const selectedImage = uploadedImages.find(img => img.id === id);
            if (!selectedImage || activeImageId === id) return;

            activeImageId = id;

            if (!selectedImage.imageObj) {
                showNotification(`Carregando '${selectedImage.name}'...`, 'success');
                selectedImage.imageObj = new Image();
                await new Promise((resolve, reject) => {
                    selectedImage.imageObj.onload = resolve;
                    selectedImage.imageObj.onerror = reject;
                    selectedImage.imageObj.src = selectedImage.dataURL;
                });
                selectedImage.imageColors = await analyzeImageColors(selectedImage.imageObj, true);
                selectedImage.composition = await analyzeImageComposition(selectedImage.imageObj);
            }
            
            updateUI();
            redrawCanvas();
            renderGallery();
        }

        function deleteImage(id) {
            const index = uploadedImages.findIndex(img => img.id === id);
            if (index === -1) return;

            uploadedImages.splice(index, 1);
            
            if (activeImageId === id) {
                activeImageId = null;
                if (uploadedImages.length > 0) {
                    const newIndex = Math.max(0, Math.min(index, uploadedImages.length - 1));
                    selectImage(uploadedImages[newIndex].id);
                } else {
                    redrawCanvas();
                    renderGallery();
                    updateUI();
                }
            } else {
                renderGallery();
            }
        }

        function clearGallery() {
            uploadedImages = [];
            activeImageId = null;
            imageIdCounter = 0;
            renderGallery();
            redrawCanvas();
            updateUI();
        }

        function updateActiveImageProp(prop, value) {
            if (activeImageId === null) return;
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (activeImage) {
                activeImage[prop] = value;
            }
        }

        function updateUI() {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            
            if (!activeImage) {
                // Reset UI to a default state if no image is selected
                document.querySelectorAll('.control-btn.active, .visual-btn.active, .headline-btn.active').forEach(el => el.classList.remove('active'));
                logoControls.classList.add('hidden');
                return;
            }

            document.querySelectorAll('#fill-mode-controls .control-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.mode === activeImage.fillMode));
            document.querySelectorAll('#play-button-controls .visual-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.type === activeImage.selectedPlayButton));
            document.querySelectorAll('#text-background-controls .control-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.style === activeImage.headlineBackgroundStyle));
            document.querySelectorAll('#format-controls .control-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.format === activeImage.selectedFormat));
            document.querySelectorAll('#font-family-controls .control-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.font === activeImage.headlineFont));
            
            const isCustomText = !defaultHeadlines.includes(activeImage.headlineText);
            document.querySelectorAll('#headline-buttons-container .headline-btn').forEach(btn => 
                btn.classList.toggle('active', btn.dataset.text === activeImage.headlineText && !isCustomText));
            
            customHeadlineInput.value = isCustomText ? activeImage.headlineText : '';

            fontSizeSlider.value = activeImage.headlineSize;
            fontSizeValue.textContent = `${activeImage.headlineSize}px`;
            qualitySlider.value = activeImage.quality;
            qualityValue.textContent = `${activeImage.quality}%`;
            textBgOpacitySlider.value = activeImage.headlineBackgroundOpacity * 100;
            textBgOpacityValue.textContent = `${Math.round(activeImage.headlineBackgroundOpacity * 100)}%`;
            playButtonSizeSlider.value = activeImage.playButtonSize;
            playButtonSizeValue.textContent = `${activeImage.playButtonSize}px`;
            brightnessSlider.value = activeImage.brightness;
            brightnessValue.textContent = `${activeImage.brightness}%`;
            contrastSlider.value = activeImage.contrast;
            contrastValue.textContent = `${activeImage.contrast}%`;
            saturateSlider.value = activeImage.saturate;
            saturateValue.textContent = `${activeImage.saturate}%`;
            
            // Atualizar controles de redimensionamento manual
            const imageScaleSlider = document.getElementById('image-scale-slider');
            const imageScaleValue = document.getElementById('image-scale-value');
            const imageXSlider = document.getElementById('image-x-slider');
            const imageXValue = document.getElementById('image-x-value');
            const imageYSlider = document.getElementById('image-y-slider');
            const imageYValue = document.getElementById('image-y-value');
            
            if (imageScaleSlider && imageScaleValue) {
                imageScaleSlider.value = activeImage.imageScale || 100;
                imageScaleValue.textContent = `${activeImage.imageScale || 100}%`;
            }
            
            if (imageXSlider && imageXValue) {
                imageXSlider.value = activeImage.imageX || 0;
                imageXValue.textContent = `${activeImage.imageX || 0}px`;
            }
            
            if (imageYSlider && imageYValue) {
                imageYSlider.value = activeImage.imageY || 0;
                imageYValue.textContent = `${activeImage.imageY || 0}px`;
            }

            textColorPicker.value = activeImage.headlineColor;
            textBgColorPicker.value = activeImage.headlineBackgroundColor;
            
            renderFillModeOptions();
            renderFilters();
            renderLogoGallery();

            logoControls.classList.toggle('hidden', activeImage.activeLogoId === null);
            if (activeImage.activeLogoId !== null) {
                logoScaleSlider.value = activeImage.logoScale;
                logoScaleValue.textContent = `${activeImage.logoScale}%`;
            }
        }

        function renderFillModeOptions() {
            fillModeOptionsContainer.innerHTML = '';
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage) return;
            
            if (activeImage.fillMode === 'blur-pro') {
                fillModeOptionsContainer.innerHTML = `
                    <div class="slider-container" style="margin-top: 0;">
                        <div class="slider-label">
                            <label for="blur-amount-slider">Intensidade do Desfoque</label>
                            <span id="blur-amount-value">${activeImage.blurAmount}px</span>
                        </div>
                        <input type="range" id="blur-amount-slider" min="10" max="120" value="${activeImage.blurAmount}">
                    </div>
                `;
                const blurSlider = document.getElementById('blur-amount-slider');
                const blurValue = document.getElementById('blur-amount-value');
                blurSlider.addEventListener('input', (e) => {
                    const val = parseInt(e.target.value);
                    blurValue.textContent = `${val}px`;
                    updateActiveImageProp('blurAmount', val);
                    redrawCanvas();
                });
            } else if (activeImage.fillMode === 'solid') {
                fillModeOptionsContainer.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <label>Cor de Fundo</label>
                        <input type="color" id="solid-fill-color-picker" value="${activeImage.solidFillColor}">
                    </div>
                `;
                const solidColorPicker = document.getElementById('solid-fill-color-picker');
                solidColorPicker.addEventListener('input', (e) => {
                    updateActiveImageProp('solidFillColor', e.target.value);
                    redrawCanvas();
                });
            } else if (activeImage.fillMode === 'smart') {
                const resolved = activeImage.smartFillCache && activeImage.smartFillCache.mode ? activeImage.smartFillCache.mode : 'calculando...';
                fillModeOptionsContainer.innerHTML = `
                    <div style="display:flex; align-items:center; gap:0.75rem; flex-wrap:wrap;">
                        <span style="font-size:0.9rem; color: var(--text-secondary);">Modo escolhido: <strong>${resolved}</strong></span>
                        <button id="recompute-smart-fill" class="btn btn-secondary">Recalcular</button>
                    </div>
                `;
                const recomputeBtn = document.getElementById('recompute-smart-fill');
                recomputeBtn.addEventListener('click', () => {
                    if (activeImage.smartFillCache) activeImage.smartFillCache = null;
                    redrawCanvas();
                    updateUI();
                });
            }
        }

        function handleControlClick(e, dataAttribute, callback, buttonClass = 'control-btn') {
            const button = e.target.closest(`.${buttonClass}`);
            if (!button) return;
            const value = button.getAttribute(dataAttribute);
            // Alterna estado visual: remove 'active' dos irmãos dentro do mesmo container
            const container = button.parentElement;
            if (container) {
                const peers = container.querySelectorAll(`.${buttonClass}`);
                peers.forEach(b => b.classList.remove('active'));
            }
            button.classList.add('active');
            if (typeof callback === 'function') callback(value, button);
        }

        function drawBackground(image) {
            const img = image.imageObj;
            const imgAspectRatio = img.width / img.height;
            const canvasAspectRatio = TARGET_WIDTH / TARGET_HEIGHT;
            let bgWidth, bgHeight, bgX, bgY;

            if (imgAspectRatio > canvasAspectRatio) {
                bgHeight = TARGET_HEIGHT;
                bgWidth = bgHeight * imgAspectRatio;
                bgX = (TARGET_WIDTH - bgWidth) / 2;
                bgY = 0;
            } else {
                bgWidth = TARGET_WIDTH;
                bgHeight = bgWidth / imgAspectRatio;
                bgX = 0;
                bgY = (TARGET_HEIGHT - bgHeight) / 2;
            }

            // Preparar filtros compostos para modos de preenchimento
            const presetFilter = FILTERS[image.filter] ? FILTERS[image.filter].value : '';
            const brightness = `brightness(${(image.brightness || 100) / 100})`;
            const contrast = `contrast(${(image.contrast || 100) / 100})`;
            const saturate = `saturate(${(image.saturate || 100) / 100})`;
            const composedFilter = [presetFilter, brightness, contrast, saturate].filter(Boolean).join(' ').trim();

            switch (image.fillMode) {
        case 'blur-pro':
            // Desenha fundo desfocado nas bordas, mantendo área central para imagem nítida
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            const blurFilter = `blur(${image.blurAmount || 40}px)`;
            ctx.filter = composedFilter ? `${blurFilter} ${composedFilter}` : blurFilter;
            ctx.drawImage(img, bgX, bgY, bgWidth, bgHeight);
            ctx.restore();
            break;
        case 'edge-extend':
            // Preenchimento suave usando blur leve nas bordas
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Usar blur muito sutil (15px) para preenchimento suave
            const edgeBlur = `blur(15px)`;
            ctx.filter = composedFilter ? `${edgeBlur} ${composedFilter}` : edgeBlur;
            ctx.drawImage(img, bgX, bgY, bgWidth, bgHeight);
            
            ctx.restore();
            break;
        case 'stretch':
            // Estica a imagem para preencher todo o canvas
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            if (composedFilter) ctx.filter = composedFilter;
            ctx.drawImage(img, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            ctx.restore();
            break;
        case 'duotone':
            // Cria efeito duotone usando as cores da imagem
            if (image.imageColors && image.imageColors.dominant) {
                const [r, g, b] = image.imageColors.dominant;
                const brightness = (r + g + b) / 3;
                const shadowColor = brightness > 128 ? '#000000' : '#FFFFFF';
                const highlightColor = `rgb(${r}, ${g}, ${b})`;
                
                ctx.save();
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                if (composedFilter) ctx.filter = composedFilter;
                ctx.drawImage(img, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = shadowColor;
                ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = highlightColor;
                ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                ctx.restore();
            } else {
                // Fallback para stretch se não houver cores analisadas
                ctx.save();
                if (composedFilter) ctx.filter = composedFilter;
                ctx.drawImage(img, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);
                ctx.restore();
            }
            break;
        case 'mosaic':
            // Cria efeito mosaico repetindo a imagem em escala reduzida
            const tileSize = Math.min(TARGET_WIDTH, TARGET_HEIGHT) / 8;
            const tilesX = Math.ceil(TARGET_WIDTH / tileSize);
            const tilesY = Math.ceil(TARGET_HEIGHT / tileSize);
            
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            if (composedFilter) ctx.filter = composedFilter;
            ctx.globalAlpha = 0.3;
            for (let x = 0; x < tilesX; x++) {
                for (let y = 0; y < tilesY; y++) {
                    ctx.drawImage(img, x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }
            ctx.restore();
            break;
        case 'gradient':
            const g = ctx.createLinearGradient(0, 0, 0, TARGET_HEIGHT);
            g.addColorStop(0, `rgb(${image.imageColors.top.join(',')})`);
            g.addColorStop(1, `rgb(${image.imageColors.bottom.join(',')})`);
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            break;
        case 'solid':
            ctx.fillStyle = image.solidFillColor;
            ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            break;
        case 'smart': {
            // Resolver melhor modo via heurística com cache
            const resolved = computeSmartFill(image);
            // Desenhar usando o modo resolvido sem alterar estado permanente do UI
            const original = image.fillMode;
            image.fillMode = resolved.mode;
            // Aplicar parâmetros resolvidos temporariamente
            const saved = { blurAmount: image.blurAmount, solidFillColor: image.solidFillColor };
            if (resolved.params) {
                if (typeof resolved.params.blurAmount === 'number') image.blurAmount = resolved.params.blurAmount;
                if (typeof resolved.params.solidFillColor === 'string') image.solidFillColor = resolved.params.solidFillColor;
            }
            // Chamada recursiva controlada
            drawBackground(image);
            // Restaurar estado
            image.fillMode = original;
            image.blurAmount = saved.blurAmount;
            image.solidFillColor = saved.solidFillColor;
            break;
        }
            }
        }

// Heurística para escolher o melhor preenchimento de borda
function computeSmartFill(image) {
    // Cache: refaz apenas quando mudar dimensões ou cores/composição
    const version = JSON.stringify({
        w: TARGET_WIDTH,
        h: TARGET_HEIGHT,
        colors: image.imageColors || null,
        comp: image.composition || null
    });
    if (image.smartFillCache && image.smartFillCache.version === version) {
        return image.smartFillCache;
    }

    const colors = image.imageColors || {};
    const dominant = colors.dominant || [40, 40, 40];
    const top = colors.top || dominant;
    const bottom = colors.bottom || dominant;

    // Sinais simples de decisão
    const paletteSize = Array.isArray(colors.palette) ? colors.palette.length : 0;
    const comp = image.composition || {};
    const subject = comp.subjectBox || {};
    const subjectArea = typeof subject.areaRatio === 'number' ? subject.areaRatio : null; // 0..1
    const subjectNarrow = typeof subject.aspectRatio === 'number' ? (subject.aspectRatio < 0.6 || subject.aspectRatio > 1.8) : false;

    // Heurísticas básicas
    let mode = 'blur-pro';
    let params = {};

    // 1) Se paleta pequena ou alto contraste → duotone/gradient
    if (paletteSize && paletteSize <= 3) {
        mode = 'duotone';
    } else if (paletteSize && paletteSize <= 5) {
        mode = 'gradient';
    }

    // 2) Se sujeito ocupa pouco espaço ou é estreito → stretch ajuda a preencher
    if ((subjectArea !== null && subjectArea < 0.25) || subjectNarrow) {
        mode = 'stretch';
    }

    // 3) Se imagem muito detalhada (supor paleta grande) → blur-pro mais forte
    if (paletteSize && paletteSize > 6) {
        mode = 'blur-pro';
        params.blurAmount = Math.min(80, Math.max(30, Math.round(0.06 * Math.max(TARGET_WIDTH, TARGET_HEIGHT))));
    }

    // 4) Fallback: se nada definido claramente, usar gradient com cores topo/base ou blur suave
    if (!mode) mode = 'gradient';

    // Parâmetros auxiliares
    if (mode === 'solid') {
        // Usar cor sólida aproximada dominante
        const [r, g, b] = dominant;
        params.solidFillColor = `#${[r, g, b].map(v => v.toString(16).padStart(2, '0')).join('')}`;
    }

    const result = { mode, params, version };
    image.smartFillCache = result;
    return result;
}
        

        // Desenha toda a composição no canvas
        // Pode ser chamado como redrawCanvas() ou redrawCanvas(image)
        function redrawCanvas(targetImage = null) {
            // Resolver imagem ativa
            const image = targetImage || uploadedImages.find(img => img.id === activeImageId);

            // Limpar canvas
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.globalAlpha = 1;
            ctx.filter = 'none';
            ctx.clearRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
            ctx.restore();

            if (!image || !image.imageObj) {
                // Nada a desenhar além do fundo neutro
                return;
            }

            // 1) Fundo de preenchimento (bordas)
            drawBackground(image);

            // 2) Imagem principal com filtros e transformações (blur-pro permite imagem nítida por cima)
            if (!['stretch', 'duotone', 'mosaic'].includes(image.fillMode)) {
                const img = image.imageObj;
                const imgAspectRatio = img.width / img.height;
                const canvasAspectRatio = TARGET_WIDTH / TARGET_HEIGHT;
                
                let mainW, mainH, mainX, mainY;
                
                // Para modos de preenchimento: imagem deve preencher a largura total
                if (['blur-pro', 'edge-extend', 'gradient', 'solid', 'smart'].includes(image.fillMode)) {
                    mainW = TARGET_WIDTH;
                    mainH = TARGET_WIDTH / imgAspectRatio;
                    mainX = 0;
                    mainY = (TARGET_HEIGHT - mainH) / 2;
                } else {
                    // Para outros modos: usar escala e posicionamento customizável
                    const scale = (image.imageScale || 100) / 100;
                    mainW = img.width * scale;
                    mainH = img.height * scale;
                    
                    // Interpretação: imageX/Y são deslocamentos em px a partir do centro do canvas
                    const centerX = TARGET_WIDTH / 2 + (image.imageX || 0);
                    const centerY = TARGET_HEIGHT / 2 + (image.imageY || 0);
                    mainX = centerX - mainW / 2;
                    mainY = centerY - mainH / 2;
                }

                // Monta filtro composto (preset + ajustes manuais)
                const presetFilter = FILTERS[image.filter] ? FILTERS[image.filter].value : '';
                const brightness = `brightness(${(image.brightness || 100) / 100})`;
                const contrast = `contrast(${(image.contrast || 100) / 100})`;
                const saturate = `saturate(${(image.saturate || 100) / 100})`;
                const composedFilter = [presetFilter, brightness, contrast, saturate].filter(Boolean).join(' ').trim();

                ctx.save();
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                if (composedFilter) ctx.filter = composedFilter;
                ctx.drawImage(img, mainX, mainY, mainW, mainH);
                ctx.restore();
            }

            // 3) Overlays: texto, logotipo, botão de play e badges de dorama
            drawTextElements(image);
            drawLogoOverlay(image);
            drawPlayButton(image);
            drawDoramaElements(image);

            // 4) Guias de snap (se ativo durante drag)
            if (snapStatus && (snapStatus.horizontal || snapStatus.vertical)) {
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 200, 120, 0.6)';
                ctx.lineWidth = 2;
                if (snapStatus.horizontal) {
                    const y = TARGET_HEIGHT / 2;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(TARGET_WIDTH, y);
                    ctx.stroke();
                }
                if (snapStatus.vertical) {
                    const x = TARGET_WIDTH / 2;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, TARGET_HEIGHT);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }
        

        function wrapText(context, text, maxWidth) {
            const words = text.split(' ');
            let line = '';
            let lines = [];

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = context.measureText(testLine);
                if (metrics.width > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line);
            return lines;
        }

        function drawTextElements(image) {
            if (!image.headlineText) return;
            ctx.save();
            const text = image.headlineText.toUpperCase();
            
            let fontFamily = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
            if (image.headlineFont === 'Impact') {
                fontFamily = "Impact, sans-serif";
            } else if (image.headlineFont === 'Anton') {
                fontFamily = "'Anton', sans-serif";
            }

            ctx.font = `bold ${image.headlineSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const { x, y, width, height } = getTextBoundingBox(image);

            if (image.headlineBackgroundStyle === 'faixa' || image.headlineBackgroundStyle === 'capsule') {
                const rgb = hexToRgb(image.headlineBackgroundColor);
                ctx.fillStyle = rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${image.headlineBackgroundOpacity})` : 'rgba(0, 0, 0, 0.6)';

                if (image.headlineBackgroundStyle === 'faixa') {
                    ctx.fillRect(0, y, TARGET_WIDTH, height);
                } else {
                    const radius = height / 2;
                    ctx.beginPath();
                    ctx.roundRect(x, y, width, height, radius);
                    ctx.fill();
                }
            }

            ctx.shadowColor = 'black';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;

            const lines = wrapText(ctx, text, TARGET_WIDTH - 80);
            const lineHeight = image.headlineSize * 1.2;
            let currentY = y + (height / 2) - ((lines.length - 1) * lineHeight / 2);

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                const textX = x + width / 2;
                if (image.headlineBackgroundStyle === 'vazado') {
                    ctx.strokeStyle = image.headlineColor;
                    ctx.lineWidth = 4;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(line, textX, currentY);
                } else {
                    ctx.fillStyle = image.headlineColor;
                    ctx.fillText(line, textX, currentY);
                }
                currentY += lineHeight;
            }
            ctx.restore();
        }

        // =================================================================
        // CORREÇÃO APLICADA AQUI
        // =================================================================
        function drawPlayButton(image) {
            const type = image.selectedPlayButton;
            if (type === 'none') return;

            const size = image.playButtonSize;
            const { x, y, width, height } = getPlayButtonBoundingBox(image);
            const cX = x + width / 2;
            const cY = y + height / 2;
            const s = size; // shorthand for size

            ctx.save();
            ctx.shadowBlur = 0; // Reset shadow for buttons
            
            switch(type) {
                case 'youtube': {
                    ctx.fillStyle = '#FF0000';
                    const rectWidth = s * 0.9;
                    const rectHeight = s * 0.65;
                    ctx.beginPath();
                    ctx.roundRect(cX - rectWidth / 2, cY - rectHeight / 2, rectWidth, rectHeight, s * 0.15);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    const triangleHeight = s * 0.35;
                    const triangleBase = s * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(cX - triangleBase / 2 + s * 0.05, cY - triangleHeight / 2);
                    ctx.lineTo(cX - triangleBase / 2 + s * 0.05, cY + triangleHeight / 2);
                    ctx.lineTo(cX + triangleBase / 2 + s * 0.05, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }
                    
                case 'new-tiktok': {
                    ctx.fillStyle = '#00F2EA';
                    ctx.beginPath();
                    ctx.arc(cX + s * 0.08, cY - s * 0.08, s * 0.33, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FF0050';
                    ctx.beginPath();
                    ctx.arc(cX - s * 0.08, cY + s * 0.08, s * 0.33, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.29, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.08, cY - s * 0.15);
                    ctx.lineTo(cX - s * 0.08, cY + s * 0.15);
                    ctx.lineTo(cX + s * 0.12, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }
                
                case 'gradient-circle': {
                    const grad = ctx.createLinearGradient(cX - s/2, cY - s/2, cX + s/2, cY + s/2);
                    grad.addColorStop(0, "#8A2BE2");
                    grad.addColorStop(1, "#00BFFF");
                    
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = s * 0.08;
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.38, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.1, cY - s * 0.18);
                    ctx.lineTo(cX - s * 0.1, cY + s * 0.18);
                    ctx.lineTo(cX + s * 0.15, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'red-circle': {
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.42, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.1, cY - s * 0.18);
                    ctx.lineTo(cX - s * 0.1, cY + s * 0.18);
                    ctx.lineTo(cX + s * 0.15, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'dashed-circle': {
                    ctx.strokeStyle = '#D32F2F';
                    ctx.lineWidth = s * 0.06;
                    ctx.setLineDash([s * 0.2, s * 0.1]);
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.38, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset dash

                    ctx.fillStyle = '#D32F2F';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.1, cY - s * 0.18);
                    ctx.lineTo(cX - s * 0.1, cY + s * 0.18);
                    ctx.lineTo(cX + s * 0.15, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'simple-circle': {
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.46, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.15, cY - s * 0.22);
                    ctx.lineTo(cX - s * 0.15, cY + s * 0.22);
                    ctx.lineTo(cX + s * 0.2, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'rounded-square': {
                    ctx.fillStyle = '#212121';
                    ctx.beginPath();
                    ctx.roundRect(cX - s * 0.42, cY - s * 0.42, s * 0.84, s * 0.84, s * 0.16);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.12, cY - s * 0.2);
                    ctx.lineTo(cX - s * 0.12, cY + s * 0.2);
                    ctx.lineTo(cX + s * 0.18, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'thick-border-circle': {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.42, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.33, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.08, cY - s * 0.15);
                    ctx.lineTo(cX - s * 0.08, cY + s * 0.15);
                    ctx.lineTo(cX + s * 0.12, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'instagram': {
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.46, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.42, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.12, cY - s * 0.20);
                    ctx.lineTo(cX - s * 0.12, cY + s * 0.20);
                    ctx.lineTo(cX + s * 0.18, cY);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }

                case 'glossy-blue': {
                    const glossyGrad = ctx.createRadialGradient(cX, cY + s*0.3, s*0.1, cX, cY, s*0.6);
                    glossyGrad.addColorStop(0, "#00529B");
                    glossyGrad.addColorStop(1, "#00BFFF");

                    ctx.fillStyle = glossyGrad;
                    ctx.beginPath();
                    ctx.arc(cX, cY, s * 0.46, 0, Math.PI * 2);
                    ctx.fill();

                    const shineGrad = ctx.createLinearGradient(cX, cY - s*0.46, cX, cY);
                    shineGrad.addColorStop(0, "rgba(255,255,255,0.6)");
                    shineGrad.addColorStop(0.5, "rgba(255,255,255,0.1)");
                    shineGrad.addColorStop(1, "rgba(255,255,255,0.0)");
                    
                    ctx.fillStyle = shineGrad;
                    ctx.beginPath();
                    ctx.arc(cX, cY - s*0.05, s*0.42, Math.PI * 1.1, Math.PI * 1.9);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = s * 0.02;
                    ctx.beginPath();
                    ctx.moveTo(cX - s * 0.13, cY - s * 0.22);
                    ctx.lineTo(cX - s * 0.13, cY + s * 0.22);
                    ctx.lineTo(cX + s * 0.2, cY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                }
            }
            
            ctx.restore();
        }
        // =================================================================
        // FIM DA CORREÇÃO
        // =================================================================

        function drawDoramaElements(image) {
            ctx.save();
            
            // Calcular o multiplicador de tamanho baseado no slider
            const sizeMultiplier = doramaElementsSize / 100;
            
            // Episode Badge
            if (doramaElements.episode) {
                const x = (doramaElements.episode.x / 100) * TARGET_WIDTH;
                const y = (doramaElements.episode.y / 100) * TARGET_HEIGHT;
                const width = 80 * sizeMultiplier;
                const height = 30 * sizeMultiplier;
                const fontSize = 16 * sizeMultiplier;
                
                ctx.fillStyle = doramaBadgeColors.episode;
                ctx.beginPath();
                ctx.roundRect(x - width/2, y - height/2, width, height, height/2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('EP 1-16', x, y);
            }
            
            // Subtitle Badge
            if (doramaElements.subtitle) {
                const x = (doramaElements.subtitle.x / 100) * TARGET_WIDTH;
                const y = (doramaElements.subtitle.y / 100) * TARGET_HEIGHT;
                const width = 70 * sizeMultiplier;
                const height = 30 * sizeMultiplier;
                const fontSize = 14 * sizeMultiplier;
                
                ctx.fillStyle = doramaBadgeColors.subtitle;
                ctx.beginPath();
                ctx.roundRect(x - width/2, y - height/2, width, height, height/2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ENG SUB', x, y);
            }
            
            // HD Badge
            if (doramaElements.hd) {
                const x = (doramaElements.hd.x / 100) * TARGET_WIDTH;
                const y = (doramaElements.hd.y / 100) * TARGET_HEIGHT;
                const width = 50 * sizeMultiplier;
                const height = 30 * sizeMultiplier;
                const fontSize = 16 * sizeMultiplier;
                
                ctx.fillStyle = doramaBadgeColors.hd;
                ctx.beginPath();
                ctx.roundRect(x - width/2, y - height/2, width, height, height/2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('HD', x, y);
            }
            
            // FULL HD Badge
            if (doramaElements.fullhd) {
                const x = (doramaElements.fullhd.x / 100) * TARGET_WIDTH;
                const y = (doramaElements.fullhd.y / 100) * TARGET_HEIGHT;
                const width = 85 * sizeMultiplier;
                const height = 30 * sizeMultiplier;
                const fontSize = 14 * sizeMultiplier;
                
                ctx.fillStyle = doramaBadgeColors.fullhd;
                ctx.beginPath();
                ctx.roundRect(x - width/2, y - height/2, width, height, height/2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('FULL HD', x, y);
            }
            
            // NEW Badge
            if (doramaElements.new) {
                const x = (doramaElements.new.x / 100) * TARGET_WIDTH;
                const y = (doramaElements.new.y / 100) * TARGET_HEIGHT;
                const width = 60 * sizeMultiplier;
                const height = 30 * sizeMultiplier;
                const fontSize = 14 * sizeMultiplier;
                
                ctx.fillStyle = doramaBadgeColors.new;
                ctx.beginPath();
                ctx.roundRect(x - width/2, y - height/2, width, height, height/2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('NEW', x, y);
            }
            
            ctx.restore();
        }

        function drawLogoOverlay(image) {
            if (image.activeLogoId === null) return;

            const logo = savedLogos.find(l => l.id === image.activeLogoId);
            if (!logo || !logo.imageObj) return;

            const { x, y, width, height } = getLogoBoundingBox(image);
            ctx.drawImage(logo.imageObj, x, y, width, height);
        }

        // Funções auxiliares continuam...
        function getTextBoundingBox(image) {
            if (!image.headlineText) return null;
            
            let fontFamily = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
            if (image.headlineFont === 'Impact') fontFamily = "Impact, sans-serif";
            else if (image.headlineFont === 'Anton') fontFamily = "'Anton', sans-serif";
            ctx.font = `bold ${image.headlineSize}px ${fontFamily}`;
            
            const lines = wrapText(ctx, image.headlineText.toUpperCase(), TARGET_WIDTH - 80);
            const lineHeight = image.headlineSize * 1.2;
            const totalTextHeight = (lines.length * lineHeight);
            const height = totalTextHeight + 40;
            
            let width;
            if (image.headlineBackgroundStyle === 'faixa') {
                width = TARGET_WIDTH;
            } else {
                const longestLine = lines.reduce((a, b) => 
                    ctx.measureText(a).width > ctx.measureText(b).width ? a : b, "");
                width = ctx.measureText(longestLine.trim()).width + 80;
            }

            const centerX = TARGET_WIDTH * (image.headlineX / 100);
            const centerY = TARGET_HEIGHT * (image.headlineY / 100);

            return { x: centerX - width / 2, y: centerY - height / 2, width, height };
        }

        function getPlayButtonBoundingBox(image) {
            if (image.selectedPlayButton === 'none') return null;
            const size = image.playButtonSize;
            
            const centerX = TARGET_WIDTH * (image.playButtonX / 100);
            const centerY = TARGET_HEIGHT * (image.playButtonY / 100);

            return { x: centerX - size / 2, y: centerY - size / 2, width: size, height: size };
        }

        function getLogoBoundingBox(image) {
            if (image.activeLogoId === null) return null;
            const logo = savedLogos.find(l => l.id === image.activeLogoId);
            if (!logo || !logo.imageObj) return null;

            const scale = image.logoScale / 100;
            const aspect = logo.imageObj.width / logo.imageObj.height;
            let width = TARGET_WIDTH * scale;
            let height = width / aspect;
            if (height > TARGET_HEIGHT * scale) {
                height = TARGET_HEIGHT * scale;
                width = height * aspect;
            }
            
            const centerX = TARGET_WIDTH * (image.logoX / 100);
            const centerY = TARGET_HEIGHT * (image.logoY / 100);

            return { x: centerX - width / 2, y: centerY - height / 2, width, height };
        }

        function getDoramaBadgeBoundingBox(type) {
            if (!doramaElements[type]) return null;
            
            const sizeMultiplier = doramaElementsSize / 100;
            const x = (doramaElements[type].x / 100) * TARGET_WIDTH;
            const y = (doramaElements[type].y / 100) * TARGET_HEIGHT;
            
            let width, height;
            switch(type) {
                case 'episode':
                    width = 80 * sizeMultiplier;
                    height = 30 * sizeMultiplier;
                    break;
                case 'subtitle':
                    width = 70 * sizeMultiplier;
                    height = 30 * sizeMultiplier;
                    break;
                case 'hd':
                    width = 50 * sizeMultiplier;
                    height = 30 * sizeMultiplier;
                    break;
                case 'fullhd':
                    width = 85 * sizeMultiplier;
                    height = 30 * sizeMultiplier;
                    break;
                case 'new':
                    width = 60 * sizeMultiplier;
                    height = 30 * sizeMultiplier;
                    break;
                default:
                    return null;
            }
            
            return { 
                x: x - width/2, 
                y: y - height/2, 
                width, 
                height,
                centerX: x,
                centerY: y,
                type: type
            };
        }

        function handleMouseDown(e) {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage) return;

            const pos = getMousePos(outputCanvas, e);
            
            const logoBox = getLogoBoundingBox(activeImage);
            const textBox = getTextBoundingBox(activeImage);
            const playBox = getPlayButtonBoundingBox(activeImage);
            
            // Verificar badges de dorama
            let doramaBadgeHit = null;
            for (const type of ['episode', 'subtitle', 'hd', 'fullhd', 'new']) {
                const badgeBox = getDoramaBadgeBoundingBox(type);
                if (badgeBox && pos.x > badgeBox.x && pos.x < badgeBox.x + badgeBox.width && 
                    pos.y > badgeBox.y && pos.y < badgeBox.y + badgeBox.height) {
                    doramaBadgeHit = { type, box: badgeBox };
                    break;
                }
            }

            let elementCenterX, elementCenterY;

            if (doramaBadgeHit) {
                draggingElement = `dorama-${doramaBadgeHit.type}`;
                elementCenterX = doramaBadgeHit.box.centerX;
                elementCenterY = doramaBadgeHit.box.centerY;
            } else if (logoBox && pos.x > logoBox.x && pos.x < logoBox.x + logoBox.width && 
                pos.y > logoBox.y && pos.y < logoBox.y + logoBox.height) {
                draggingElement = 'logo';
                elementCenterX = logoBox.x + logoBox.width / 2;
                elementCenterY = logoBox.y + logoBox.height / 2;
            } else if (textBox && pos.x > textBox.x && pos.x < textBox.x + textBox.width && 
                       pos.y > textBox.y && pos.y < textBox.y + textBox.height) {
                draggingElement = 'text';
                elementCenterX = textBox.x + textBox.width / 2;
                elementCenterY = textBox.y + textBox.height / 2;
            } else if (playBox && pos.x > playBox.x && pos.x < playBox.x + playBox.width && 
                       pos.y > playBox.y && pos.y < playBox.y + playBox.height) {
                draggingElement = 'playButton';
                elementCenterX = playBox.x + playBox.width / 2;
                elementCenterY = playBox.y + playBox.height / 2;
            } else {
                return;
            }

            isDragging = true;
            dragOffsetX = pos.x - elementCenterX;
            dragOffsetY = pos.y - elementCenterY;
            outputCanvas.classList.add('grabbing');
        }

        function handleMouseMove(e) {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage) return;

            const pos = getMousePos(outputCanvas, e);
            
            const logoBox = getLogoBoundingBox(activeImage);
            const textBox = getTextBoundingBox(activeImage);
            const playBox = getPlayButtonBoundingBox(activeImage);
            
            // Verificar badges de dorama para cursor
            let overDoramaBadge = false;
            for (const type of ['episode', 'subtitle', 'hd', 'fullhd', 'new']) {
                const badgeBox = getDoramaBadgeBoundingBox(type);
                if (badgeBox && pos.x > badgeBox.x && pos.x < badgeBox.x + badgeBox.width && 
                    pos.y > badgeBox.y && pos.y < badgeBox.y + badgeBox.height) {
                    overDoramaBadge = true;
                    break;
                }
            }

            if (!isDragging) {
                if (overDoramaBadge ||
                    (logoBox && pos.x > logoBox.x && pos.x < logoBox.x + logoBox.width && 
                     pos.y > logoBox.y && pos.y < logoBox.y + logoBox.height) ||
                    (textBox && pos.x > textBox.x && pos.x < textBox.x + textBox.width && 
                     pos.y > textBox.y && pos.y < textBox.y + textBox.height) ||
                    (playBox && pos.x > playBox.x && pos.x < playBox.x + playBox.width && 
                     pos.y > playBox.y && pos.y < playBox.y + playBox.height)) {
                    outputCanvas.classList.add('grab');
                } else {
                    outputCanvas.classList.remove('grab');
                }
                return;
            }
            
            if (isDragging && draggingElement) {
                let newCenterX = pos.x - dragOffsetX;
                let newCenterY = pos.y - dragOffsetY;
                
                const snapThreshold = 10;

                // Snap Horizontal
                if (Math.abs(newCenterY - TARGET_HEIGHT / 2) < snapThreshold) {
                    newCenterY = TARGET_HEIGHT / 2;
                    snapStatus.horizontal = true;
                } else {
                    snapStatus.horizontal = false;
                }

                // Snap Vertical
                if (draggingElement !== 'text' || activeImage.headlineBackgroundStyle !== 'faixa') {
                    if (Math.abs(newCenterX - TARGET_WIDTH / 2) < snapThreshold) {
                        newCenterX = TARGET_WIDTH / 2;
                        snapStatus.vertical = true;
                    } else {
                        snapStatus.vertical = false;
                    }
                } else {
                    snapStatus.vertical = false;
                }
                
                // Verificar se está arrastando um badge de dorama
                if (draggingElement.startsWith('dorama-')) {
                    const badgeType = draggingElement.replace('dorama-', '');
                    if (doramaElements[badgeType]) {
                        doramaElements[badgeType].x = (newCenterX / TARGET_WIDTH) * 100;
                        doramaElements[badgeType].y = (newCenterY / TARGET_HEIGHT) * 100;
                    }
                } else if (draggingElement === 'logo') {
                    updateActiveImageProp('logoX', (newCenterX / TARGET_WIDTH) * 100);
                    updateActiveImageProp('logoY', (newCenterY / TARGET_HEIGHT) * 100);
                } else if (draggingElement === 'text') {
                    if (activeImage.headlineBackgroundStyle !== 'faixa') {
                        updateActiveImageProp('headlineX', (newCenterX / TARGET_WIDTH) * 100);
                    }
                    updateActiveImageProp('headlineY', (newCenterY / TARGET_HEIGHT) * 100);
                } else if (draggingElement === 'playButton') {
                    updateActiveImageProp('playButtonX', (newCenterX / TARGET_WIDTH) * 100);
                    updateActiveImageProp('playButtonY', (newCenterY / TARGET_HEIGHT) * 100);
                }
                
                redrawCanvas();
            }
        }

        function handleMouseUp(e) {
            if (isDragging) {
                isDragging = false;
                draggingElement = null;
                snapStatus = { horizontal: false, vertical: false };
                outputCanvas.classList.remove('grabbing');
                redrawCanvas();
                updateUI();
            }
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) / rect.width * TARGET_WIDTH,
                y: (evt.clientY - rect.top) / rect.height * TARGET_HEIGHT
            };
        }

        async function processImage() {
            if (isProcessing || activeImageId === null) return;
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage) return;

            isProcessing = true;
            processBtn.disabled = true;
            generateVariationsBtn.disabled = true;
            processBtn.textContent = 'Processando...';
            showNotification('Iniciando compressão...', 'success');
            
            redrawCanvas(activeImage);
            await new Promise(resolve => setTimeout(resolve, 50));
            processedBlob = await createCompressedBlob(activeImage);
            
            isProcessing = false;
            processBtn.disabled = false;
            generateVariationsBtn.disabled = false;
            processBtn.textContent = 'Exportar Imagem';

            if (processedBlob) {
                const finalSize = (processedBlob.size / 1024).toFixed(2);
                showNotification(`Sucesso! Tamanho final: ${finalSize}KB`, 'success');
                
                const name = exportFilenameInput.value.trim() || 
                             activeImage.name.split('.').slice(0, -1).join('.') || 
                             `criativo_${Date.now()}`;
                const format = activeImage.selectedFormat;
                
                downloadDirect(processedBlob, name, format);
            } else {
                showNotification('Falha ao comprimir a imagem.', 'error');
            }
        }

        async function createCompressedBlob(image) {
            let quality = image.quality / 100;
            const mimeType = `image/${image.selectedFormat}`;
            
            redrawCanvas(image);
            await new Promise(resolve => setTimeout(resolve, 50));

            const blob = await new Promise(resolve => 
                outputCanvas.toBlob(resolve, mimeType, quality));
            
            if (blob.size / 1024 > MAX_FILE_SIZE_KB) {
                const reducedQualityBlob = await new Promise(resolve => 
                    outputCanvas.toBlob(resolve, mimeType, 0.7));
                return reducedQualityBlob;
            }
            
            return blob;
        }

        function downloadDirect(blob, name, format) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${name}.${format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('Download iniciado!', 'success');
        }

        // Funções auxiliares
        function hexToRgb(hex) {
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function showNotification(message, type = 'success') {
            notification.textContent = message;
            notification.className = type;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function renderFilters() {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            filtersContainer.innerHTML = '';

            if (!activeImage) {
                filtersContainer.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9rem;">Selecione uma imagem para ver os filtros.</p>';
                return;
            }

            for (const key in FILTERS) {
                const filter = FILTERS[key];
                const itemContainer = document.createElement('div');
                itemContainer.className = 'filter-item';
                itemContainer.dataset.filter = key;

                const thumb = document.createElement('div');
                thumb.className = 'filter-thumbnail';
                thumb.style.backgroundImage = `url(${activeImage.dataURL})`;
                thumb.style.filter = filter.value;

                if (activeImage.filter === key) {
                    thumb.classList.add('active');
                }

                const nameEl = document.createElement('p');
                nameEl.className = 'filter-name';
                nameEl.textContent = filter.name;

                itemContainer.appendChild(thumb);
                itemContainer.appendChild(nameEl);
                filtersContainer.appendChild(itemContainer);
            }
        }

        function handleTemplateClick(e) {
            const deleteBtn = e.target.closest('.delete-template-btn');
            const templateBtn = e.target.closest('.control-btn');

            if (deleteBtn) {
                e.stopPropagation();
                const templateName = templateBtn.dataset.template;
                if (defaultTemplates[templateName]) {
                    deleteDefaultTemplate(templateName);
                } else {
                    deleteCustomTemplate(templateName);
                }
            } else if (templateBtn) {
                applyTemplate(templateBtn.dataset.template);
            }
        }

        function applyTemplate(templateName) {
            if (activeImageId === null) return;
            const allTemplates = {
                ...Object.keys(defaultTemplates).reduce((acc, key) => 
                    ({...acc, [key]: defaultTemplates[key].settings}), {}),
                ...customTemplates.reduce((acc, t) => 
                    ({...acc, [t.name]: t.settings}), {})
            };
            const template = allTemplates[templateName];
            if (!template) return;

            for (const prop in template) {
                updateActiveImageProp(prop, template[prop]);
            }
            redrawCanvas();
            updateUI();
            showNotification(`Template '${templateName}' aplicado!`, 'success');
        }

        function saveNewTemplate() {
            const name = newTemplateNameInput.value.trim();
            if (!name) {
                showNotification('Por favor, dê um nome ao template.', 'error');
                return;
            }
            if (defaultTemplates[name] || customTemplates.find(t => t.name === name)) {
                showNotification('Já existe um template com esse nome.', 'error');
                return;
            }
            if (activeImageId === null) {
                showNotification('Selecione uma imagem para salvar o estilo.', 'error');
                return;
            }
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            const newTemplate = {
                name: name,
                settings: {
                    brightness: activeImage.brightness,
                    contrast: activeImage.contrast,
                    saturate: activeImage.saturate,
                    headlineFont: activeImage.headlineFont,
                    headlineColor: activeImage.headlineColor,
                    headlineSize: activeImage.headlineSize,
                    headlineBackgroundStyle: activeImage.headlineBackgroundStyle,
                    headlineBackgroundColor: activeImage.headlineBackgroundColor,
                    headlineBackgroundOpacity: activeImage.headlineBackgroundOpacity,
                }
            };
            customTemplates.push(newTemplate);
            saveCustomTemplates();
            renderAllTemplates();
            newTemplateNameInput.value = '';
            showNotification('Template salvo com sucesso!', 'success');
        }

        function deleteDefaultTemplate(name) {
            if (!deletedDefaultTemplates.includes(name)) {
                deletedDefaultTemplates.push(name);
                saveDeletedDefaultTemplates();
                renderAllTemplates();
                showNotification(`Template '${name}' excluído.`, 'success');
            }
        }

        function deleteCustomTemplate(name) {
            customTemplates = customTemplates.filter(t => t.name !== name);
            saveCustomTemplates();
            renderAllTemplates();
            showNotification('Template excluído!', 'success');
        }

        function resetDefaultTemplates() {
            deletedDefaultTemplates = [];
            saveDeletedDefaultTemplates();
            renderAllTemplates();
            showNotification('Templates padrão restaurados!', 'success');
        }

        function saveCustomTemplates() {
            localStorage.setItem('creativeProTemplates', JSON.stringify(customTemplates));
        }

        function saveDeletedDefaultTemplates() {
            localStorage.setItem('deletedDefaultTemplates', JSON.stringify(deletedDefaultTemplates));
        }

        function loadCustomTemplates() {
            const saved = localStorage.getItem('creativeProTemplates');
            if (saved) {
                customTemplates = JSON.parse(saved);
            }
        }

        function loadDeletedDefaultTemplates() {
            const saved = localStorage.getItem('deletedDefaultTemplates');
            if (saved) {
                deletedDefaultTemplates = JSON.parse(saved);
            }
        }

        function renderAllTemplates() {
            templateControls.innerHTML = '';
            for (const key in defaultTemplates) {
                if (!deletedDefaultTemplates.includes(key)) {
                    const template = defaultTemplates[key];
                    const btn = document.createElement('button');
                    btn.className = 'control-btn';
                    btn.textContent = template.name;
                    btn.dataset.template = key;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-template-btn';
                    deleteBtn.innerHTML = '&times;';
                    btn.appendChild(deleteBtn);
                    templateControls.appendChild(btn);
                }
            }
            
            customTemplatesContainer.innerHTML = '';
            customTemplates.forEach(template => {
                const btn = document.createElement('button');
                btn.className = 'control-btn';
                btn.textContent = template.name;
                btn.dataset.template = template.name;

                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'delete-template-btn';
                deleteBtn.innerHTML = '&times;';
                btn.appendChild(deleteBtn);
                customTemplatesContainer.appendChild(btn);
            });
        }

        // Logo functions
        function loadSavedLogos() {
            const saved = localStorage.getItem('creativeProLogos');
            if (saved) {
                savedLogos = JSON.parse(saved);
                savedLogos.forEach(logo => {
                    const img = new Image();
                    img.src = logo.dataURL;
                    logo.imageObj = img;
                });
                logoIdCounter = savedLogos.length > 0 ? 
                    Math.max(...savedLogos.map(l => l.id)) + 1 : 0;
            }
            renderLogoGallery();
        }

        function saveLogos() {
            const logosToSave = savedLogos.map(logo => 
                ({ id: logo.id, name: logo.name, dataURL: logo.dataURL }));
            localStorage.setItem('creativeProLogos', JSON.stringify(logosToSave));
        }

        function handleLogoUpload(files) {
            if (!files.length) return;
            const file = files[0];
            if (!file.type.startsWith('image/')) {
                showNotification('Por favor, selecione um arquivo de imagem (PNG, WebP).', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const newLogo = {
                        id: logoIdCounter++,
                        name: file.name,
                        dataURL: e.target.result,
                        imageObj: img
                    };
                    savedLogos.push(newLogo);
                    saveLogos();
                    renderLogoGallery();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function renderLogoGallery() {
            logoGalleryContainer.innerHTML = '';
            const activeImage = uploadedImages.find(img => img.id === activeImageId);

            savedLogos.forEach(logo => {
                const itemContainer = document.createElement('div');
                itemContainer.className = 'gallery-item';
                itemContainer.title = logo.name;
                itemContainer.dataset.id = logo.id;

                const thumb = document.createElement('div');
                thumb.className = 'gallery-thumbnail';
                thumb.style.backgroundImage = `url(${logo.dataURL})`;
                thumb.dataset.action = 'select';

                if (activeImage && activeImage.activeLogoId === logo.id) {
                    thumb.classList.add('active');
                }

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.dataset.action = 'delete';

                itemContainer.appendChild(deleteBtn);
                itemContainer.appendChild(thumb);
                logoGalleryContainer.appendChild(itemContainer);
            });
        }

        function handleLogoGalleryClick(e) {
            const item = e.target.closest('.gallery-item');
            if (!item || activeImageId === null) return;

            const logoId = parseInt(item.dataset.id);
            const action = e.target.dataset.action;

            if (action === 'delete') {
                e.stopPropagation();
                savedLogos = savedLogos.filter(l => l.id !== logoId);
                saveLogos();
                renderLogoGallery();
                uploadedImages.forEach(img => {
                    if (img.activeLogoId === logoId) {
                        img.activeLogoId = null;
                    }
                });
                redrawCanvas();
                updateUI();
            } else if (action === 'select') {
                updateActiveImageProp('activeLogoId', logoId);
                redrawCanvas();
                updateUI();
            }
        }

        // Batch and variations functions
        async function generateAutomaticVariations() {
            // Implementação simplificada por questão de espaço
            showNotification('Função de variações em desenvolvimento...', 'success');
        }

        async function processBatch() {
            // Implementação simplificada por questão de espaço
            showNotification('Processamento em lote em desenvolvimento...', 'success');
        }

        // Função para adicionar/remover elementos de doramas (chamada por eventos)
        function toggleDoramaElement(type) {
            const activeImage = uploadedImages.find(img => img.id === activeImageId);
            if (!activeImage) {
                showNotification('Selecione uma imagem primeiro!', 'error');
                return;
            }

            // Toggle do elemento
            if (doramaElements[type]) {
                doramaElements[type] = null;
                // Esconder o controle se nenhum elemento estiver ativo
                const hasActiveElements = Object.values(doramaElements).some(el => el !== null);
                if (!hasActiveElements) {
                    doramaElementsControls.style.display = 'none';
                }
            } else {
                // Posicionar em locais diferentes para cada badge
                let initialX = 85;
                let initialY = 15;
                
                // Ajustar posição inicial baseado no tipo
                switch(type) {
                    case 'episode':
                        initialX = 15;
                        initialY = 15;
                        break;
                    case 'subtitle':
                        initialX = 85;
                        initialY = 15;
                        break;
                    case 'hd':
                        initialX = 15;
                        initialY = 85;
                        break;
                    case 'fullhd':
                        initialX = 50;
                        initialY = 85;
                        break;
                    case 'new':
                        initialX = 85;
                        initialY = 85;
                        break;
                }
                
                doramaElements[type] = {
                    type: type,
                    x: initialX,
                    y: initialY
                };
                // Mostrar o controle quando houver elementos ativos
                doramaElementsControls.style.display = 'block';
                
                // Atualizar cor do picker com a cor do badge ativo
                doramaBadgeColorPicker.value = doramaBadgeColors[type];
            }
            
            // Atualizar visual dos botões (versão com data-dorama)
            document.querySelectorAll('button[data-dorama]').forEach(btn => {
                const t = btn.getAttribute('data-dorama');
                btn.classList.toggle('active', !!doramaElements[t]);
            });
            
            redrawCanvas();
        }

        // Função global para resetar cores dos badges
        window.resetBadgeColors = function() {
            Object.keys(defaultBadgeColors).forEach(type => {
                doramaBadgeColors[type] = defaultBadgeColors[type];
            });
            // Atualizar o color picker com a cor padrão do primeiro badge ativo
            const activeTypes = Object.keys(doramaElements).filter(type => doramaElements[type] !== null);
            if (activeTypes.length > 0) {
                doramaBadgeColorPicker.value = doramaBadgeColors[activeTypes[0]];
            }
            requestRedraw();
            showNotification('Cores dos badges restauradas!', 'success');
        }

        // =================================================================
        // FUNCIONALIDADES DE IA
        // =================================================================
        
        // Configuração de APIs
        let apiKeys = {
            removeBg: localStorage.getItem('removeBgApiKey') || '',
            openai: localStorage.getItem('openaiApiKey') || ''
        };
        
        // Elementos do painel IA
        const removeBgBtn = document.getElementById('remove-bg-btn');
        const removeBgStatus = document.getElementById('remove-bg-status');
        const upscaleBtn = document.getElementById('upscale-btn');
        const upscaleStatus = document.getElementById('upscale-status');
        const generateTextBtn = document.getElementById('generate-text-btn');
        const aiTextPrompt = document.getElementById('ai-text-prompt');
        const aiTextResults = document.getElementById('ai-text-results');
        const aiTextLanguage = document.getElementById('text-language');
        const analyzeBtn = document.getElementById('analyze-composition-btn');
        const compositionSuggestions = document.getElementById('composition-suggestions');
        const saveApiKeysBtn = document.getElementById('save-api-keys');
        
        // Salvar API Keys
        if (saveApiKeysBtn) {
            saveApiKeysBtn.addEventListener('click', () => {
                const removeBgKey = document.getElementById('removebg-api-key').value;
                const openaiKey = document.getElementById('openai-api-key').value;
                
                if (removeBgKey) {
                    apiKeys.removeBg = removeBgKey;
                    localStorage.setItem('removeBgApiKey', removeBgKey);
                }
                if (openaiKey) {
                    apiKeys.openai = openaiKey;
                    localStorage.setItem('openaiApiKey', openaiKey);
                }
                
                showNotification('API Keys salvas com sucesso!', 'success');
            });
        }
        
        // 1. REMOVER FUNDO COM REMOVE.BG
        if (removeBgBtn) {
            removeBgBtn.addEventListener('click', async () => {
                const activeImage = uploadedImages.find(img => img.id === activeImageId);
                if (!activeImage) {
                    showNotification('Selecione uma imagem primeiro!', 'error');
                    return;
                }
                
                if (!apiKeys.removeBg) {
                    showNotification('Configure sua API Key do Remove.bg primeiro!', 'error');
                    return;
                }
                
                removeBgStatus.textContent = '⏳ Processando...';
                removeBgBtn.disabled = true;
                
                try {
                    // Converter canvas para blob
                    const blob = await new Promise(resolve => 
                        outputCanvas.toBlob(resolve, 'image/png'));
                    
                    const formData = new FormData();
                    formData.append('image_file', blob, 'image.png');
                    formData.append('size', 'auto');
                    
                    const response = await fetch('https://api.remove.bg/v1.0/removebg', {
                        method: 'POST',
                        headers: {
                            'X-Api-Key': apiKeys.removeBg
                        },
                        body: formData
                    });
                    
                    if (response.ok) {
                        const arrayBuffer = await response.arrayBuffer();
                        const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                        const dataURL = `data:image/png;base64,${base64}`;
                        
                        // Criar nova imagem sem fundo
                        const newImage = {
                            ...activeImage,
                            id: imageIdCounter++,
                            name: activeImage.name.replace(/\.\w+$/, '_sem_fundo.png'),
                            dataURL: dataURL,
                            imageObj: null
                        };
                        
                        uploadedImages.push(newImage);
                        selectImage(newImage.id);
                        
                        removeBgStatus.textContent = '✅ Fundo removido com sucesso!';
                        showNotification('Fundo removido! Nova imagem adicionada.', 'success');
                    } else {
                        throw new Error('Erro na API');
                    }
                } catch (error) {
                    removeBgStatus.textContent = '❌ Erro ao remover fundo';
                    showNotification('Erro ao remover fundo: ' + error.message, 'error');
                } finally {
                    removeBgBtn.disabled = false;
                }
            });
        }
        
        // 2. UPSCALE DE IMAGEM (Simulado com Canvas)
        if (upscaleBtn) {
            upscaleBtn.addEventListener('click', async () => {
                const activeImage = uploadedImages.find(img => img.id === activeImageId);
                if (!activeImage || !activeImage.imageObj) {
                    showNotification('Selecione uma imagem primeiro!', 'error');
                    return;
                }
                
                upscaleStatus.textContent = '⏳ Aumentando resolução...';
                upscaleBtn.disabled = true;
                
                const factor = parseInt(document.getElementById('upscale-factor').value);
                
                try {
                    // Criar canvas temporário maior
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    tempCanvas.width = TARGET_WIDTH * factor;
                    tempCanvas.height = TARGET_HEIGHT * factor;
                    
                    // Configurar qualidade máxima
                    tempCtx.imageSmoothingEnabled = true;
                    tempCtx.imageSmoothingQuality = 'high';
                    
                    // Desenhar imagem em alta resolução
                    tempCtx.drawImage(activeImage.imageObj, 0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // Converter para dataURL
                    const dataURL = tempCanvas.toDataURL('image/png', 1.0);
                    
                    // Criar nova imagem upscaled
                    const newImage = {
                        ...activeImage,
                        id: imageIdCounter++,
                        name: activeImage.name.replace(/\.\w+$/, `_${factor}x.png`),
                        dataURL: dataURL,
                        imageObj: null
                    };
                    
                    uploadedImages.push(newImage);
                    selectImage(newImage.id);
                    
                    upscaleStatus.textContent = `✅ Resolução aumentada ${factor}x!`;
                    showNotification(`Imagem ampliada ${factor}x com sucesso!`, 'success');
                } catch (error) {
                    upscaleStatus.textContent = '❌ Erro no upscale';
                    showNotification('Erro ao ampliar imagem: ' + error.message, 'error');
                } finally {
                    upscaleBtn.disabled = false;
                }
            });
        }
        
        // 3. GERAR TEXTO CRIATIVO COM OPENAI
        if (generateTextBtn) {
            generateTextBtn.addEventListener('click', async () => {
                const prompt = aiTextPrompt.value.trim();
                if (!prompt) {
                    showNotification('Digite um prompt para gerar texto!', 'error');
                    return;
                }
                
                if (!apiKeys.openai) {
                    // Fallback multilíngue focado em Doramas
                    const style = document.getElementById('text-style').value;
                    const lang = aiTextLanguage ? aiTextLanguage.value : 'en';
                    const fallbackTexts = {
                        en: {
                            romantic: ["LOVE BEYOND FATE","WHEN HEARTS BLOOM","MY SWEET FIRST LOVE","STARS THAT UNITE US"],
                            dramatic: ["AUTUMN TEARS","THE PRICE OF TRUTH","DANGEROUS SECRETS","THE LAST PROMISE"],
                            comedy: ["MY BOSS IS A DISASTER!","LOVE CONFUSIONS","SINGLE LIFE","LAUGHING OUT LOUD"],
                            thriller: ["SHADOWS OF THE PAST","THE INVISIBLE STALKER","SILENT REVENGE","CRIMINAL MIND"],
                            viral: ["YOU WON'T BELIEVE IT!","WHAT HE DID SHOCKED EVERYONE","BOMBSHELL REVELATION","TRY NOT TO CRY"]
                        },
                        es: {
                            romantic: ["AMOR MÁS ALLÁ DEL DESTINO","CUANDO FLORECE EL CORAZÓN","MI DULCE PRIMER AMOR","ESTRELLAS QUE NOS UNEN"],
                            dramatic: ["LÁGRIMAS DE OTOÑO","EL PRECIO DE LA VERDAD","SECRETOS PELIGROSOS","LA ÚLTIMA PROMESA"],
                            comedy: ["¡MI JEFE ES UN DESASTRE!","CONFUSIONES DEL AMOR","VIDA DE SOLTERO","RIENDO A CARCAJADAS"],
                            thriller: ["SOMBRAS DEL PASADO","EL ACOSADOR INVISIBLE","VENGANZA SILENCIOSA","MENTE CRIMINAL"],
                            viral: ["¡NO LO VAS A CREER!","LO QUE HIZO SORPRENDIÓ A TODOS","REVELACIÓN BOMBA","IMPOSIBLE NO LLORAR"]
                        }
                    };
                    const texts = (fallbackTexts[lang] && fallbackTexts[lang][style]) || fallbackTexts.en.romantic;
                    aiTextResults.innerHTML = '<strong>Sugestões de texto:</strong><br>';
                    texts.forEach(text => {
                        const btn = document.createElement('button');
                        btn.className = 'text-suggestion-btn';
                        btn.textContent = text;
                        btn.style.cssText = 'display: block; width: 100%; text-align: left; padding: 0.5rem; margin: 0.25rem 0; background: var(--bg-panel); border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer;';
                        btn.onclick = () => {
                            updateActiveImageProp('headlineText', text);
                            requestRedraw();
                            showNotification('Texto aplicado!', 'success');
                        };
                        aiTextResults.appendChild(btn);
                    });
                    return;
                }

                aiTextResults.textContent = '⏳ Gerando textos criativos...';
                generateTextBtn.disabled = true;

                try {
                    const style = document.getElementById('text-style').value;
                    const lang = aiTextLanguage ? aiTextLanguage.value : 'en';
                    const systemByLang = {
                        en: `You are an expert at crafting short, punchy titles for K-dramas (Korean TV series). Always keep it focused on Doramas. Style: ${style}. Generate 4 short, impactful options in English only.`,
                        es: `Eres experto en crear títulos cortos e impactantes para Doramas (series coreanas). Mantén siempre el enfoque en Doramas. Estilo: ${style}. Genera 4 opciones cortas en español.`
                    };
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKeys.openai}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [{
                                role: 'system',
                                content: systemByLang[lang]
                            }, {
                                role: 'user',
                                content: `${prompt}\nContext: Doramas/K-dramas only. Return plain list (no extra commentary).`
                            }],
                            temperature: 0.8,
                            max_tokens: 100
                        })
                    });
                    
                    const data = await response.json();
                    const suggestions = data.choices[0].message.content.split('\n').filter(t => t.trim());
                    
                    aiTextResults.innerHTML = '<strong>Textos gerados:</strong><br>';
                    suggestions.forEach(text => {
                        const cleanText = text.replace(/^\d+\.?\s*/, '').replace(/^[−–-•]\s*/, '').trim();
                        const btn = document.createElement('button');
                        btn.className = 'text-suggestion-btn';
                        btn.textContent = cleanText;
                        btn.style.cssText = 'display: block; width: 100%; text-align: left; padding: 0.5rem; margin: 0.25rem 0; background: var(--bg-panel); border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer;';
                        btn.onclick = () => {
                            updateActiveImageProp('headlineText', cleanText);
                            requestRedraw();
                            showNotification('Texto aplicado!', 'success');
                        };
                        aiTextResults.appendChild(btn);
                    });
                } catch (error) {
                    aiTextResults.textContent = '❌ Erro ao gerar texto';
                    showNotification('Erro: ' + error.message, 'error');
                } finally {
                    generateTextBtn.disabled = false;
                }
            });
        }
        
        // 4. ANÁLISE DE COMPOSIÇÃO
        if (analyzeBtn) {
            analyzeBtn.addEventListener('click', () => {
                const activeImage = uploadedImages.find(img => img.id === activeImageId);
                if (!activeImage) {
                    showNotification('Selecione uma imagem primeiro!', 'error');
                    return;
                }
                
                compositionSuggestions.innerHTML = '<strong>📊 Análise da Composição:</strong><br><br>';
                
                // Análise baseada em regras
                const suggestions = [];
                
                // Verificar texto
                if (activeImage.headlineText === defaultHeadlines[0]) {
                    suggestions.push('💡 Personalize o texto para maior impacto');
                }
                
                // Verificar contraste
                if (activeImage.brightness < 80 || activeImage.brightness > 120) {
                    suggestions.push('🔆 Ajuste o brilho para melhor legibilidade');
                }
                
                // Verificar saturação
                if (activeImage.saturate < 80) {
                    suggestions.push('🎨 Aumente a saturação para cores mais vibrantes');
                }
                
                // Verificar elementos
                if (activeImage.selectedPlayButton === 'none') {
                    suggestions.push('▶️ Adicione um botão de play para maior engajamento');
                }
                
                // Verificar filtros
                if (activeImage.filter === 'none') {
                    suggestions.push('✨ Experimente filtros para criar atmosfera');
                }
                
                // Regra dos terços
                if (activeImage.headlineY < 30 || activeImage.headlineY > 70) {
                    suggestions.push('📐 Posicione o texto seguindo a regra dos terços');
                }
                
                // Badges de dorama
                const hasBadges = Object.values(doramaElements).some(el => el !== null);
                if (!hasBadges) {
                    suggestions.push('🏷️ Adicione badges (EP, SUB, HD) para contexto');
                }
                
                if (suggestions.length === 0) {
                    suggestions.push('✅ Composição bem equilibrada!');
                    suggestions.push('🎯 Considere testar variações para A/B testing');
                }
                
                suggestions.forEach(sugg => {
                    const p = document.createElement('p');
                    p.style.cssText = 'margin: 0.5rem 0; padding: 0.5rem; background: var(--bg-dark); border-radius: 4px;';
                    p.textContent = sugg;
                    compositionSuggestions.appendChild(p);
                });
                
                // Score de qualidade
                const score = Math.max(0, 100 - (suggestions.length - 1) * 15);
                const scoreEl = document.createElement('div');
                scoreEl.style.cssText = 'margin-top: 1rem; padding: 0.75rem; background: var(--accent); border-radius: 8px; text-align: center; font-weight: bold;';
                scoreEl.innerHTML = `🏆 Score de Qualidade: ${score}/100`;
                compositionSuggestions.appendChild(scoreEl);
            });
        }

        // Inicializar aplicação
        initializeApp();
    });
    </script>
</body>
</html>
